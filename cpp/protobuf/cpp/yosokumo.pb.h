// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yosokumo.proto

#ifndef PROTOBUF_yosokumo_2eproto__INCLUDED
#define PROTOBUF_yosokumo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ProtoBuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_yosokumo_2eproto();
void protobuf_AssignDesc_yosokumo_2eproto();
void protobuf_ShutdownFile_yosokumo_2eproto();

class Catalog;
class Study;
class Study_Owner;
class Study_Table;
class Study_Model;
class Study_Panel;
class Study_Roster;
class Roster;
class Role;
class Role_Roleholder;
class Role_Privileges;
class Role_Study;
class Panel;
class Panel_StudyNameControl;
class Panel_TypeControl;
class Panel_StatusControl;
class Panel_VisibilityControl;
class Panel_BlockCountControl;
class Panel_CellCountControl;
class Panel_ProspectCountControl;
class Panel_CreationTimeControl;
class Panel_LatestBlockTimeControl;
class Panel_LatestProspectTimeControl;
class Block;
class Predictor;
class Specimen;
class Cell;
class Message;

enum Study_Type {
  Study_Type_Class = 1,
  Study_Type_Rank = 2,
  Study_Type_Number = 3,
  Study_Type_Chance = 4
};
bool Study_Type_IsValid(int value);
const Study_Type Study_Type_Type_MIN = Study_Type_Class;
const Study_Type Study_Type_Type_MAX = Study_Type_Chance;
const int Study_Type_Type_ARRAYSIZE = Study_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Study_Type_descriptor();
inline const ::std::string& Study_Type_Name(Study_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Study_Type_descriptor(), value);
}
inline bool Study_Type_Parse(
    const ::std::string& name, Study_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Study_Type>(
    Study_Type_descriptor(), name, value);
}
enum Study_Status {
  Study_Status_Running = 1,
  Study_Status_Standby = 2,
  Study_Status_Stopped = 3
};
bool Study_Status_IsValid(int value);
const Study_Status Study_Status_Status_MIN = Study_Status_Running;
const Study_Status Study_Status_Status_MAX = Study_Status_Stopped;
const int Study_Status_Status_ARRAYSIZE = Study_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Study_Status_descriptor();
inline const ::std::string& Study_Status_Name(Study_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Study_Status_descriptor(), value);
}
inline bool Study_Status_Parse(
    const ::std::string& name, Study_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Study_Status>(
    Study_Status_descriptor(), name, value);
}
enum Study_Visibility {
  Study_Visibility_Private = 1,
  Study_Visibility_Public = 2
};
bool Study_Visibility_IsValid(int value);
const Study_Visibility Study_Visibility_Visibility_MIN = Study_Visibility_Private;
const Study_Visibility Study_Visibility_Visibility_MAX = Study_Visibility_Public;
const int Study_Visibility_Visibility_ARRAYSIZE = Study_Visibility_Visibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* Study_Visibility_descriptor();
inline const ::std::string& Study_Visibility_Name(Study_Visibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    Study_Visibility_descriptor(), value);
}
inline bool Study_Visibility_Parse(
    const ::std::string& name, Study_Visibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Study_Visibility>(
    Study_Visibility_descriptor(), name, value);
}
enum Predictor_Status {
  Predictor_Status_Active = 1,
  Predictor_Status_Inactive = 2
};
bool Predictor_Status_IsValid(int value);
const Predictor_Status Predictor_Status_Status_MIN = Predictor_Status_Active;
const Predictor_Status Predictor_Status_Status_MAX = Predictor_Status_Inactive;
const int Predictor_Status_Status_ARRAYSIZE = Predictor_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Predictor_Status_descriptor();
inline const ::std::string& Predictor_Status_Name(Predictor_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Predictor_Status_descriptor(), value);
}
inline bool Predictor_Status_Parse(
    const ::std::string& name, Predictor_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Predictor_Status>(
    Predictor_Status_descriptor(), name, value);
}
enum Predictor_Type {
  Predictor_Type_Categorical = 1,
  Predictor_Type_Continuous = 2
};
bool Predictor_Type_IsValid(int value);
const Predictor_Type Predictor_Type_Type_MIN = Predictor_Type_Categorical;
const Predictor_Type Predictor_Type_Type_MAX = Predictor_Type_Continuous;
const int Predictor_Type_Type_ARRAYSIZE = Predictor_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Predictor_Type_descriptor();
inline const ::std::string& Predictor_Type_Name(Predictor_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Predictor_Type_descriptor(), value);
}
inline bool Predictor_Type_Parse(
    const ::std::string& name, Predictor_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Predictor_Type>(
    Predictor_Type_descriptor(), name, value);
}
enum Predictor_Level {
  Predictor_Level_Nominal = 1,
  Predictor_Level_Ordinal = 2,
  Predictor_Level_Interval = 3,
  Predictor_Level_Ratio = 4
};
bool Predictor_Level_IsValid(int value);
const Predictor_Level Predictor_Level_Level_MIN = Predictor_Level_Nominal;
const Predictor_Level Predictor_Level_Level_MAX = Predictor_Level_Ratio;
const int Predictor_Level_Level_ARRAYSIZE = Predictor_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* Predictor_Level_descriptor();
inline const ::std::string& Predictor_Level_Name(Predictor_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    Predictor_Level_descriptor(), value);
}
inline bool Predictor_Level_Parse(
    const ::std::string& name, Predictor_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Predictor_Level>(
    Predictor_Level_descriptor(), name, value);
}
enum Specimen_Status {
  Specimen_Status_Active = 1,
  Specimen_Status_Inactive = 2
};
bool Specimen_Status_IsValid(int value);
const Specimen_Status Specimen_Status_Status_MIN = Specimen_Status_Active;
const Specimen_Status Specimen_Status_Status_MAX = Specimen_Status_Inactive;
const int Specimen_Status_Status_ARRAYSIZE = Specimen_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Specimen_Status_descriptor();
inline const ::std::string& Specimen_Status_Name(Specimen_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Specimen_Status_descriptor(), value);
}
inline bool Specimen_Status_Parse(
    const ::std::string& name, Specimen_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Specimen_Status>(
    Specimen_Status_descriptor(), name, value);
}
enum Message_Type {
  Message_Type_Information = 1,
  Message_Type_Error = 2
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_Information;
const Message_Type Message_Type_Type_MAX = Message_Type_Error;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
// ===================================================================

class Catalog : public ::google::protobuf::Message {
 public:
  Catalog();
  virtual ~Catalog();

  Catalog(const Catalog& from);

  inline Catalog& operator=(const Catalog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Catalog& default_instance();

  void Swap(Catalog* other);

  // implements Message ----------------------------------------------

  Catalog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Catalog& from);
  void MergeFrom(const Catalog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_identifier = 1;
  inline bool has_user_identifier() const;
  inline void clear_user_identifier();
  static const int kUserIdentifierFieldNumber = 1;
  inline const ::std::string& user_identifier() const;
  inline void set_user_identifier(const ::std::string& value);
  inline void set_user_identifier(const char* value);
  inline void set_user_identifier(const char* value, size_t size);
  inline ::std::string* mutable_user_identifier();
  inline ::std::string* release_user_identifier();
  inline void set_allocated_user_identifier(::std::string* user_identifier);

  // optional string user_name = 102;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 102;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string location = 103;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 103;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // repeated .ProtoBuf.Study study = 4;
  inline int study_size() const;
  inline void clear_study();
  static const int kStudyFieldNumber = 4;
  inline const ::ProtoBuf::Study& study(int index) const;
  inline ::ProtoBuf::Study* mutable_study(int index);
  inline ::ProtoBuf::Study* add_study();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Study >&
      study() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Study >*
      mutable_study();

  // @@protoc_insertion_point(class_scope:ProtoBuf.Catalog)
 private:
  inline void set_has_user_identifier();
  inline void clear_has_user_identifier();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_identifier_;
  ::std::string* user_name_;
  ::std::string* location_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Study > study_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Catalog* default_instance_;
};
// -------------------------------------------------------------------

class Study_Owner : public ::google::protobuf::Message {
 public:
  Study_Owner();
  virtual ~Study_Owner();

  Study_Owner(const Study_Owner& from);

  inline Study_Owner& operator=(const Study_Owner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study_Owner& default_instance();

  void Swap(Study_Owner* other);

  // implements Message ----------------------------------------------

  Study_Owner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study_Owner& from);
  void MergeFrom(const Study_Owner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_identifier = 1;
  inline bool has_user_identifier() const;
  inline void clear_user_identifier();
  static const int kUserIdentifierFieldNumber = 1;
  inline const ::std::string& user_identifier() const;
  inline void set_user_identifier(const ::std::string& value);
  inline void set_user_identifier(const char* value);
  inline void set_user_identifier(const char* value, size_t size);
  inline ::std::string* mutable_user_identifier();
  inline ::std::string* release_user_identifier();
  inline void set_allocated_user_identifier(::std::string* user_identifier);

  // optional string user_name = 102;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 102;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study.Owner)
 private:
  inline void set_has_user_identifier();
  inline void clear_has_user_identifier();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_identifier_;
  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study_Owner* default_instance_;
};
// -------------------------------------------------------------------

class Study_Table : public ::google::protobuf::Message {
 public:
  Study_Table();
  virtual ~Study_Table();

  Study_Table(const Study_Table& from);

  inline Study_Table& operator=(const Study_Table& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study_Table& default_instance();

  void Swap(Study_Table* other);

  // implements Message ----------------------------------------------

  Study_Table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study_Table& from);
  void MergeFrom(const Study_Table& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string location = 101;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 101;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study.Table)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study_Table* default_instance_;
};
// -------------------------------------------------------------------

class Study_Model : public ::google::protobuf::Message {
 public:
  Study_Model();
  virtual ~Study_Model();

  Study_Model(const Study_Model& from);

  inline Study_Model& operator=(const Study_Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study_Model& default_instance();

  void Swap(Study_Model* other);

  // implements Message ----------------------------------------------

  Study_Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study_Model& from);
  void MergeFrom(const Study_Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string location = 101;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 101;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study.Model)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study_Model* default_instance_;
};
// -------------------------------------------------------------------

class Study_Panel : public ::google::protobuf::Message {
 public:
  Study_Panel();
  virtual ~Study_Panel();

  Study_Panel(const Study_Panel& from);

  inline Study_Panel& operator=(const Study_Panel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study_Panel& default_instance();

  void Swap(Study_Panel* other);

  // implements Message ----------------------------------------------

  Study_Panel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study_Panel& from);
  void MergeFrom(const Study_Panel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string location = 101;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 101;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study.Panel)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study_Panel* default_instance_;
};
// -------------------------------------------------------------------

class Study_Roster : public ::google::protobuf::Message {
 public:
  Study_Roster();
  virtual ~Study_Roster();

  Study_Roster(const Study_Roster& from);

  inline Study_Roster& operator=(const Study_Roster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study_Roster& default_instance();

  void Swap(Study_Roster* other);

  // implements Message ----------------------------------------------

  Study_Roster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study_Roster& from);
  void MergeFrom(const Study_Roster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string location = 101;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 101;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study.Roster)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study_Roster* default_instance_;
};
// -------------------------------------------------------------------

class Study : public ::google::protobuf::Message {
 public:
  Study();
  virtual ~Study();

  Study(const Study& from);

  inline Study& operator=(const Study& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Study& default_instance();

  void Swap(Study* other);

  // implements Message ----------------------------------------------

  Study* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Study& from);
  void MergeFrom(const Study& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Study_Owner Owner;
  typedef Study_Table Table;
  typedef Study_Model Model;
  typedef Study_Panel Panel;
  typedef Study_Roster Roster;

  typedef Study_Type Type;
  static const Type Class = Study_Type_Class;
  static const Type Rank = Study_Type_Rank;
  static const Type Number = Study_Type_Number;
  static const Type Chance = Study_Type_Chance;
  static inline bool Type_IsValid(int value) {
    return Study_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Study_Type_Type_MIN;
  static const Type Type_MAX =
    Study_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Study_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Study_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Study_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Study_Type_Parse(name, value);
  }

  typedef Study_Status Status;
  static const Status Running = Study_Status_Running;
  static const Status Standby = Study_Status_Standby;
  static const Status Stopped = Study_Status_Stopped;
  static inline bool Status_IsValid(int value) {
    return Study_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Study_Status_Status_MIN;
  static const Status Status_MAX =
    Study_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Study_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Study_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Study_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Study_Status_Parse(name, value);
  }

  typedef Study_Visibility Visibility;
  static const Visibility Private = Study_Visibility_Private;
  static const Visibility Public = Study_Visibility_Public;
  static inline bool Visibility_IsValid(int value) {
    return Study_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    Study_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    Study_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    Study_Visibility_Visibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Visibility_descriptor() {
    return Study_Visibility_descriptor();
  }
  static inline const ::std::string& Visibility_Name(Visibility value) {
    return Study_Visibility_Name(value);
  }
  static inline bool Visibility_Parse(const ::std::string& name,
      Visibility* value) {
    return Study_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string study_identifier = 1;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 1;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string study_name = 102;
  inline bool has_study_name() const;
  inline void clear_study_name();
  static const int kStudyNameFieldNumber = 102;
  inline const ::std::string& study_name() const;
  inline void set_study_name(const ::std::string& value);
  inline void set_study_name(const char* value);
  inline void set_study_name(const char* value, size_t size);
  inline ::std::string* mutable_study_name();
  inline ::std::string* release_study_name();
  inline void set_allocated_study_name(::std::string* study_name);

  // optional .ProtoBuf.Study.Type type = 103;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 103;
  inline ::ProtoBuf::Study_Type type() const;
  inline void set_type(::ProtoBuf::Study_Type value);

  // optional .ProtoBuf.Study.Status status = 104;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 104;
  inline ::ProtoBuf::Study_Status status() const;
  inline void set_status(::ProtoBuf::Study_Status value);

  // optional .ProtoBuf.Study.Visibility visibility = 105;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 105;
  inline ::ProtoBuf::Study_Visibility visibility() const;
  inline void set_visibility(::ProtoBuf::Study_Visibility value);

  // optional string location = 106;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 106;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional .ProtoBuf.Study.Owner owner = 107;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 107;
  inline const ::ProtoBuf::Study_Owner& owner() const;
  inline ::ProtoBuf::Study_Owner* mutable_owner();
  inline ::ProtoBuf::Study_Owner* release_owner();
  inline void set_allocated_owner(::ProtoBuf::Study_Owner* owner);

  // optional .ProtoBuf.Study.Table table = 108;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 108;
  inline const ::ProtoBuf::Study_Table& table() const;
  inline ::ProtoBuf::Study_Table* mutable_table();
  inline ::ProtoBuf::Study_Table* release_table();
  inline void set_allocated_table(::ProtoBuf::Study_Table* table);

  // optional .ProtoBuf.Study.Model model = 109;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 109;
  inline const ::ProtoBuf::Study_Model& model() const;
  inline ::ProtoBuf::Study_Model* mutable_model();
  inline ::ProtoBuf::Study_Model* release_model();
  inline void set_allocated_model(::ProtoBuf::Study_Model* model);

  // optional .ProtoBuf.Study.Panel panel = 110;
  inline bool has_panel() const;
  inline void clear_panel();
  static const int kPanelFieldNumber = 110;
  inline const ::ProtoBuf::Study_Panel& panel() const;
  inline ::ProtoBuf::Study_Panel* mutable_panel();
  inline ::ProtoBuf::Study_Panel* release_panel();
  inline void set_allocated_panel(::ProtoBuf::Study_Panel* panel);

  // optional .ProtoBuf.Study.Roster roster = 111;
  inline bool has_roster() const;
  inline void clear_roster();
  static const int kRosterFieldNumber = 111;
  inline const ::ProtoBuf::Study_Roster& roster() const;
  inline ::ProtoBuf::Study_Roster* mutable_roster();
  inline ::ProtoBuf::Study_Roster* release_roster();
  inline void set_allocated_roster(::ProtoBuf::Study_Roster* roster);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Study)
 private:
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_study_name();
  inline void clear_has_study_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_panel();
  inline void clear_has_panel();
  inline void set_has_roster();
  inline void clear_has_roster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* study_name_;
  int type_;
  int status_;
  ::std::string* location_;
  ::ProtoBuf::Study_Owner* owner_;
  ::ProtoBuf::Study_Table* table_;
  ::ProtoBuf::Study_Model* model_;
  ::ProtoBuf::Study_Panel* panel_;
  ::ProtoBuf::Study_Roster* roster_;
  int visibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Study* default_instance_;
};
// -------------------------------------------------------------------

class Roster : public ::google::protobuf::Message {
 public:
  Roster();
  virtual ~Roster();

  Roster(const Roster& from);

  inline Roster& operator=(const Roster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Roster& default_instance();

  void Swap(Roster* other);

  // implements Message ----------------------------------------------

  Roster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Roster& from);
  void MergeFrom(const Roster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string study_identifier = 1;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 1;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string study_name = 102;
  inline bool has_study_name() const;
  inline void clear_study_name();
  static const int kStudyNameFieldNumber = 102;
  inline const ::std::string& study_name() const;
  inline void set_study_name(const ::std::string& value);
  inline void set_study_name(const char* value);
  inline void set_study_name(const char* value, size_t size);
  inline ::std::string* mutable_study_name();
  inline ::std::string* release_study_name();
  inline void set_allocated_study_name(::std::string* study_name);

  // optional string location = 103;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 103;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // repeated .ProtoBuf.Role role = 4;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 4;
  inline const ::ProtoBuf::Role& role(int index) const;
  inline ::ProtoBuf::Role* mutable_role(int index);
  inline ::ProtoBuf::Role* add_role();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Role >&
      role() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Role >*
      mutable_role();

  // @@protoc_insertion_point(class_scope:ProtoBuf.Roster)
 private:
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_study_name();
  inline void clear_has_study_name();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* study_name_;
  ::std::string* location_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Role > role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Roster* default_instance_;
};
// -------------------------------------------------------------------

class Role_Roleholder : public ::google::protobuf::Message {
 public:
  Role_Roleholder();
  virtual ~Role_Roleholder();

  Role_Roleholder(const Role_Roleholder& from);

  inline Role_Roleholder& operator=(const Role_Roleholder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_Roleholder& default_instance();

  void Swap(Role_Roleholder* other);

  // implements Message ----------------------------------------------

  Role_Roleholder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role_Roleholder& from);
  void MergeFrom(const Role_Roleholder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_identifier = 1;
  inline bool has_user_identifier() const;
  inline void clear_user_identifier();
  static const int kUserIdentifierFieldNumber = 1;
  inline const ::std::string& user_identifier() const;
  inline void set_user_identifier(const ::std::string& value);
  inline void set_user_identifier(const char* value);
  inline void set_user_identifier(const char* value, size_t size);
  inline ::std::string* mutable_user_identifier();
  inline ::std::string* release_user_identifier();
  inline void set_allocated_user_identifier(::std::string* user_identifier);

  // optional string user_name = 102;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 102;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Role.Roleholder)
 private:
  inline void set_has_user_identifier();
  inline void clear_has_user_identifier();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_identifier_;
  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Role_Roleholder* default_instance_;
};
// -------------------------------------------------------------------

class Role_Privileges : public ::google::protobuf::Message {
 public:
  Role_Privileges();
  virtual ~Role_Privileges();

  Role_Privileges(const Role_Privileges& from);

  inline Role_Privileges& operator=(const Role_Privileges& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_Privileges& default_instance();

  void Swap(Role_Privileges* other);

  // implements Message ----------------------------------------------

  Role_Privileges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role_Privileges& from);
  void MergeFrom(const Role_Privileges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool get_study = 1;
  inline bool has_get_study() const;
  inline void clear_get_study();
  static const int kGetStudyFieldNumber = 1;
  inline bool get_study() const;
  inline void set_get_study(bool value);

  // optional bool delete_study = 2;
  inline bool has_delete_study() const;
  inline void clear_delete_study();
  static const int kDeleteStudyFieldNumber = 2;
  inline bool delete_study() const;
  inline void set_delete_study(bool value);

  // optional bool get_roster = 3;
  inline bool has_get_roster() const;
  inline void clear_get_roster();
  static const int kGetRosterFieldNumber = 3;
  inline bool get_roster() const;
  inline void set_get_roster(bool value);

  // optional bool post_roster = 4;
  inline bool has_post_roster() const;
  inline void clear_post_roster();
  static const int kPostRosterFieldNumber = 4;
  inline bool post_roster() const;
  inline void set_post_roster(bool value);

  // optional bool get_role = 5;
  inline bool has_get_role() const;
  inline void clear_get_role();
  static const int kGetRoleFieldNumber = 5;
  inline bool get_role() const;
  inline void set_get_role(bool value);

  // optional bool put_role = 6;
  inline bool has_put_role() const;
  inline void clear_put_role();
  static const int kPutRoleFieldNumber = 6;
  inline bool put_role() const;
  inline void set_put_role(bool value);

  // optional bool delete_role = 7;
  inline bool has_delete_role() const;
  inline void clear_delete_role();
  static const int kDeleteRoleFieldNumber = 7;
  inline bool delete_role() const;
  inline void set_delete_role(bool value);

  // optional bool get_panel = 8;
  inline bool has_get_panel() const;
  inline void clear_get_panel();
  static const int kGetPanelFieldNumber = 8;
  inline bool get_panel() const;
  inline void set_get_panel(bool value);

  // optional bool get_control = 9;
  inline bool has_get_control() const;
  inline void clear_get_control();
  static const int kGetControlFieldNumber = 9;
  inline bool get_control() const;
  inline void set_get_control(bool value);

  // optional bool put_control = 10;
  inline bool has_put_control() const;
  inline void clear_put_control();
  static const int kPutControlFieldNumber = 10;
  inline bool put_control() const;
  inline void set_put_control(bool value);

  // optional bool post_table = 11;
  inline bool has_post_table() const;
  inline void clear_post_table();
  static const int kPostTableFieldNumber = 11;
  inline bool post_table() const;
  inline void set_post_table(bool value);

  // optional bool get_model = 12;
  inline bool has_get_model() const;
  inline void clear_get_model();
  static const int kGetModelFieldNumber = 12;
  inline bool get_model() const;
  inline void set_get_model(bool value);

  // optional bool post_model = 13;
  inline bool has_post_model() const;
  inline void clear_post_model();
  static const int kPostModelFieldNumber = 13;
  inline bool post_model() const;
  inline void set_post_model(bool value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Role.Privileges)
 private:
  inline void set_has_get_study();
  inline void clear_has_get_study();
  inline void set_has_delete_study();
  inline void clear_has_delete_study();
  inline void set_has_get_roster();
  inline void clear_has_get_roster();
  inline void set_has_post_roster();
  inline void clear_has_post_roster();
  inline void set_has_get_role();
  inline void clear_has_get_role();
  inline void set_has_put_role();
  inline void clear_has_put_role();
  inline void set_has_delete_role();
  inline void clear_has_delete_role();
  inline void set_has_get_panel();
  inline void clear_has_get_panel();
  inline void set_has_get_control();
  inline void clear_has_get_control();
  inline void set_has_put_control();
  inline void clear_has_put_control();
  inline void set_has_post_table();
  inline void clear_has_post_table();
  inline void set_has_get_model();
  inline void clear_has_get_model();
  inline void set_has_post_model();
  inline void clear_has_post_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool get_study_;
  bool delete_study_;
  bool get_roster_;
  bool post_roster_;
  bool get_role_;
  bool put_role_;
  bool delete_role_;
  bool get_panel_;
  bool get_control_;
  bool put_control_;
  bool post_table_;
  bool get_model_;
  bool post_model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Role_Privileges* default_instance_;
};
// -------------------------------------------------------------------

class Role_Study : public ::google::protobuf::Message {
 public:
  Role_Study();
  virtual ~Role_Study();

  Role_Study(const Role_Study& from);

  inline Role_Study& operator=(const Role_Study& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_Study& default_instance();

  void Swap(Role_Study* other);

  // implements Message ----------------------------------------------

  Role_Study* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role_Study& from);
  void MergeFrom(const Role_Study& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string study_identifier = 1;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 1;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string study_name = 102;
  inline bool has_study_name() const;
  inline void clear_study_name();
  static const int kStudyNameFieldNumber = 102;
  inline const ::std::string& study_name() const;
  inline void set_study_name(const ::std::string& value);
  inline void set_study_name(const char* value);
  inline void set_study_name(const char* value, size_t size);
  inline ::std::string* mutable_study_name();
  inline ::std::string* release_study_name();
  inline void set_allocated_study_name(::std::string* study_name);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Role.Study)
 private:
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_study_name();
  inline void clear_has_study_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* study_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Role_Study* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Role_Roleholder Roleholder;
  typedef Role_Privileges Privileges;
  typedef Role_Study Study;

  // accessors -------------------------------------------------------

  // optional string location = 101;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 101;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional .ProtoBuf.Role.Roleholder roleholder = 102;
  inline bool has_roleholder() const;
  inline void clear_roleholder();
  static const int kRoleholderFieldNumber = 102;
  inline const ::ProtoBuf::Role_Roleholder& roleholder() const;
  inline ::ProtoBuf::Role_Roleholder* mutable_roleholder();
  inline ::ProtoBuf::Role_Roleholder* release_roleholder();
  inline void set_allocated_roleholder(::ProtoBuf::Role_Roleholder* roleholder);

  // optional .ProtoBuf.Role.Privileges privileges = 103;
  inline bool has_privileges() const;
  inline void clear_privileges();
  static const int kPrivilegesFieldNumber = 103;
  inline const ::ProtoBuf::Role_Privileges& privileges() const;
  inline ::ProtoBuf::Role_Privileges* mutable_privileges();
  inline ::ProtoBuf::Role_Privileges* release_privileges();
  inline void set_allocated_privileges(::ProtoBuf::Role_Privileges* privileges);

  // optional .ProtoBuf.Role.Study study = 104;
  inline bool has_study() const;
  inline void clear_study();
  static const int kStudyFieldNumber = 104;
  inline const ::ProtoBuf::Role_Study& study() const;
  inline ::ProtoBuf::Role_Study* mutable_study();
  inline ::ProtoBuf::Role_Study* release_study();
  inline void set_allocated_study(::ProtoBuf::Role_Study* study);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Role)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_roleholder();
  inline void clear_has_roleholder();
  inline void set_has_privileges();
  inline void clear_has_privileges();
  inline void set_has_study();
  inline void clear_has_study();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* location_;
  ::ProtoBuf::Role_Roleholder* roleholder_;
  ::ProtoBuf::Role_Privileges* privileges_;
  ::ProtoBuf::Role_Study* study_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class Panel_StudyNameControl : public ::google::protobuf::Message {
 public:
  Panel_StudyNameControl();
  virtual ~Panel_StudyNameControl();

  Panel_StudyNameControl(const Panel_StudyNameControl& from);

  inline Panel_StudyNameControl& operator=(const Panel_StudyNameControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_StudyNameControl& default_instance();

  void Swap(Panel_StudyNameControl* other);

  // implements Message ----------------------------------------------

  Panel_StudyNameControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_StudyNameControl& from);
  void MergeFrom(const Panel_StudyNameControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string study_name = 1;
  inline bool has_study_name() const;
  inline void clear_study_name();
  static const int kStudyNameFieldNumber = 1;
  inline const ::std::string& study_name() const;
  inline void set_study_name(const ::std::string& value);
  inline void set_study_name(const char* value);
  inline void set_study_name(const char* value, size_t size);
  inline ::std::string* mutable_study_name();
  inline ::std::string* release_study_name();
  inline void set_allocated_study_name(::std::string* study_name);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string location = 103;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 103;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.StudyNameControl)
 private:
  inline void set_has_study_name();
  inline void clear_has_study_name();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_name_;
  ::std::string* study_identifier_;
  ::std::string* location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_StudyNameControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_TypeControl : public ::google::protobuf::Message {
 public:
  Panel_TypeControl();
  virtual ~Panel_TypeControl();

  Panel_TypeControl(const Panel_TypeControl& from);

  inline Panel_TypeControl& operator=(const Panel_TypeControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_TypeControl& default_instance();

  void Swap(Panel_TypeControl* other);

  // implements Message ----------------------------------------------

  Panel_TypeControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_TypeControl& from);
  void MergeFrom(const Panel_TypeControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoBuf.Study.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ProtoBuf::Study_Type type() const;
  inline void set_type(::ProtoBuf::Study_Type value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.TypeControl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_TypeControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_StatusControl : public ::google::protobuf::Message {
 public:
  Panel_StatusControl();
  virtual ~Panel_StatusControl();

  Panel_StatusControl(const Panel_StatusControl& from);

  inline Panel_StatusControl& operator=(const Panel_StatusControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_StatusControl& default_instance();

  void Swap(Panel_StatusControl* other);

  // implements Message ----------------------------------------------

  Panel_StatusControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_StatusControl& from);
  void MergeFrom(const Panel_StatusControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoBuf.Study.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::ProtoBuf::Study_Status status() const;
  inline void set_status(::ProtoBuf::Study_Status value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string location = 103;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 103;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.StatusControl)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* location_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_StatusControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_VisibilityControl : public ::google::protobuf::Message {
 public:
  Panel_VisibilityControl();
  virtual ~Panel_VisibilityControl();

  Panel_VisibilityControl(const Panel_VisibilityControl& from);

  inline Panel_VisibilityControl& operator=(const Panel_VisibilityControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_VisibilityControl& default_instance();

  void Swap(Panel_VisibilityControl* other);

  // implements Message ----------------------------------------------

  Panel_VisibilityControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_VisibilityControl& from);
  void MergeFrom(const Panel_VisibilityControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoBuf.Study.Visibility visibility = 1;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  inline ::ProtoBuf::Study_Visibility visibility() const;
  inline void set_visibility(::ProtoBuf::Study_Visibility value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string location = 103;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 103;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.VisibilityControl)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* location_;
  int visibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_VisibilityControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_BlockCountControl : public ::google::protobuf::Message {
 public:
  Panel_BlockCountControl();
  virtual ~Panel_BlockCountControl();

  Panel_BlockCountControl(const Panel_BlockCountControl& from);

  inline Panel_BlockCountControl& operator=(const Panel_BlockCountControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_BlockCountControl& default_instance();

  void Swap(Panel_BlockCountControl* other);

  // implements Message ----------------------------------------------

  Panel_BlockCountControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_BlockCountControl& from);
  void MergeFrom(const Panel_BlockCountControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 block_count = 1;
  inline bool has_block_count() const;
  inline void clear_block_count();
  static const int kBlockCountFieldNumber = 1;
  inline ::google::protobuf::uint64 block_count() const;
  inline void set_block_count(::google::protobuf::uint64 value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.BlockCountControl)
 private:
  inline void set_has_block_count();
  inline void clear_has_block_count();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 block_count_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_BlockCountControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_CellCountControl : public ::google::protobuf::Message {
 public:
  Panel_CellCountControl();
  virtual ~Panel_CellCountControl();

  Panel_CellCountControl(const Panel_CellCountControl& from);

  inline Panel_CellCountControl& operator=(const Panel_CellCountControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_CellCountControl& default_instance();

  void Swap(Panel_CellCountControl* other);

  // implements Message ----------------------------------------------

  Panel_CellCountControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_CellCountControl& from);
  void MergeFrom(const Panel_CellCountControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cell_count = 1;
  inline bool has_cell_count() const;
  inline void clear_cell_count();
  static const int kCellCountFieldNumber = 1;
  inline ::google::protobuf::uint64 cell_count() const;
  inline void set_cell_count(::google::protobuf::uint64 value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.CellCountControl)
 private:
  inline void set_has_cell_count();
  inline void clear_has_cell_count();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cell_count_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_CellCountControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_ProspectCountControl : public ::google::protobuf::Message {
 public:
  Panel_ProspectCountControl();
  virtual ~Panel_ProspectCountControl();

  Panel_ProspectCountControl(const Panel_ProspectCountControl& from);

  inline Panel_ProspectCountControl& operator=(const Panel_ProspectCountControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_ProspectCountControl& default_instance();

  void Swap(Panel_ProspectCountControl* other);

  // implements Message ----------------------------------------------

  Panel_ProspectCountControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_ProspectCountControl& from);
  void MergeFrom(const Panel_ProspectCountControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 prospect_count = 1;
  inline bool has_prospect_count() const;
  inline void clear_prospect_count();
  static const int kProspectCountFieldNumber = 1;
  inline ::google::protobuf::uint64 prospect_count() const;
  inline void set_prospect_count(::google::protobuf::uint64 value);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.ProspectCountControl)
 private:
  inline void set_has_prospect_count();
  inline void clear_has_prospect_count();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 prospect_count_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_ProspectCountControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_CreationTimeControl : public ::google::protobuf::Message {
 public:
  Panel_CreationTimeControl();
  virtual ~Panel_CreationTimeControl();

  Panel_CreationTimeControl(const Panel_CreationTimeControl& from);

  inline Panel_CreationTimeControl& operator=(const Panel_CreationTimeControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_CreationTimeControl& default_instance();

  void Swap(Panel_CreationTimeControl* other);

  // implements Message ----------------------------------------------

  Panel_CreationTimeControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_CreationTimeControl& from);
  void MergeFrom(const Panel_CreationTimeControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string creation_time = 1;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 1;
  inline const ::std::string& creation_time() const;
  inline void set_creation_time(const ::std::string& value);
  inline void set_creation_time(const char* value);
  inline void set_creation_time(const char* value, size_t size);
  inline ::std::string* mutable_creation_time();
  inline ::std::string* release_creation_time();
  inline void set_allocated_creation_time(::std::string* creation_time);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.CreationTimeControl)
 private:
  inline void set_has_creation_time();
  inline void clear_has_creation_time();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* creation_time_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_CreationTimeControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_LatestBlockTimeControl : public ::google::protobuf::Message {
 public:
  Panel_LatestBlockTimeControl();
  virtual ~Panel_LatestBlockTimeControl();

  Panel_LatestBlockTimeControl(const Panel_LatestBlockTimeControl& from);

  inline Panel_LatestBlockTimeControl& operator=(const Panel_LatestBlockTimeControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_LatestBlockTimeControl& default_instance();

  void Swap(Panel_LatestBlockTimeControl* other);

  // implements Message ----------------------------------------------

  Panel_LatestBlockTimeControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_LatestBlockTimeControl& from);
  void MergeFrom(const Panel_LatestBlockTimeControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string latest_block_time = 1;
  inline bool has_latest_block_time() const;
  inline void clear_latest_block_time();
  static const int kLatestBlockTimeFieldNumber = 1;
  inline const ::std::string& latest_block_time() const;
  inline void set_latest_block_time(const ::std::string& value);
  inline void set_latest_block_time(const char* value);
  inline void set_latest_block_time(const char* value, size_t size);
  inline ::std::string* mutable_latest_block_time();
  inline ::std::string* release_latest_block_time();
  inline void set_allocated_latest_block_time(::std::string* latest_block_time);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.LatestBlockTimeControl)
 private:
  inline void set_has_latest_block_time();
  inline void clear_has_latest_block_time();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* latest_block_time_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_LatestBlockTimeControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel_LatestProspectTimeControl : public ::google::protobuf::Message {
 public:
  Panel_LatestProspectTimeControl();
  virtual ~Panel_LatestProspectTimeControl();

  Panel_LatestProspectTimeControl(const Panel_LatestProspectTimeControl& from);

  inline Panel_LatestProspectTimeControl& operator=(const Panel_LatestProspectTimeControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel_LatestProspectTimeControl& default_instance();

  void Swap(Panel_LatestProspectTimeControl* other);

  // implements Message ----------------------------------------------

  Panel_LatestProspectTimeControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel_LatestProspectTimeControl& from);
  void MergeFrom(const Panel_LatestProspectTimeControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string latest_prospect_time = 1;
  inline bool has_latest_prospect_time() const;
  inline void clear_latest_prospect_time();
  static const int kLatestProspectTimeFieldNumber = 1;
  inline const ::std::string& latest_prospect_time() const;
  inline void set_latest_prospect_time(const ::std::string& value);
  inline void set_latest_prospect_time(const char* value);
  inline void set_latest_prospect_time(const char* value, size_t size);
  inline ::std::string* mutable_latest_prospect_time();
  inline ::std::string* release_latest_prospect_time();
  inline void set_allocated_latest_prospect_time(::std::string* latest_prospect_time);

  // optional string study_identifier = 102;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 102;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel.LatestProspectTimeControl)
 private:
  inline void set_has_latest_prospect_time();
  inline void clear_has_latest_prospect_time();
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* latest_prospect_time_;
  ::std::string* study_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel_LatestProspectTimeControl* default_instance_;
};
// -------------------------------------------------------------------

class Panel : public ::google::protobuf::Message {
 public:
  Panel();
  virtual ~Panel();

  Panel(const Panel& from);

  inline Panel& operator=(const Panel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Panel& default_instance();

  void Swap(Panel* other);

  // implements Message ----------------------------------------------

  Panel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Panel& from);
  void MergeFrom(const Panel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Panel_StudyNameControl StudyNameControl;
  typedef Panel_TypeControl TypeControl;
  typedef Panel_StatusControl StatusControl;
  typedef Panel_VisibilityControl VisibilityControl;
  typedef Panel_BlockCountControl BlockCountControl;
  typedef Panel_CellCountControl CellCountControl;
  typedef Panel_ProspectCountControl ProspectCountControl;
  typedef Panel_CreationTimeControl CreationTimeControl;
  typedef Panel_LatestBlockTimeControl LatestBlockTimeControl;
  typedef Panel_LatestProspectTimeControl LatestProspectTimeControl;

  // accessors -------------------------------------------------------

  // required string study_identifier = 1;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 1;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional string location = 102;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 102;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional .ProtoBuf.Panel.StudyNameControl study_name_control = 103;
  inline bool has_study_name_control() const;
  inline void clear_study_name_control();
  static const int kStudyNameControlFieldNumber = 103;
  inline const ::ProtoBuf::Panel_StudyNameControl& study_name_control() const;
  inline ::ProtoBuf::Panel_StudyNameControl* mutable_study_name_control();
  inline ::ProtoBuf::Panel_StudyNameControl* release_study_name_control();
  inline void set_allocated_study_name_control(::ProtoBuf::Panel_StudyNameControl* study_name_control);

  // optional .ProtoBuf.Panel.TypeControl type_control = 104;
  inline bool has_type_control() const;
  inline void clear_type_control();
  static const int kTypeControlFieldNumber = 104;
  inline const ::ProtoBuf::Panel_TypeControl& type_control() const;
  inline ::ProtoBuf::Panel_TypeControl* mutable_type_control();
  inline ::ProtoBuf::Panel_TypeControl* release_type_control();
  inline void set_allocated_type_control(::ProtoBuf::Panel_TypeControl* type_control);

  // optional .ProtoBuf.Panel.StatusControl status_control = 105;
  inline bool has_status_control() const;
  inline void clear_status_control();
  static const int kStatusControlFieldNumber = 105;
  inline const ::ProtoBuf::Panel_StatusControl& status_control() const;
  inline ::ProtoBuf::Panel_StatusControl* mutable_status_control();
  inline ::ProtoBuf::Panel_StatusControl* release_status_control();
  inline void set_allocated_status_control(::ProtoBuf::Panel_StatusControl* status_control);

  // optional .ProtoBuf.Panel.VisibilityControl visibility_control = 106;
  inline bool has_visibility_control() const;
  inline void clear_visibility_control();
  static const int kVisibilityControlFieldNumber = 106;
  inline const ::ProtoBuf::Panel_VisibilityControl& visibility_control() const;
  inline ::ProtoBuf::Panel_VisibilityControl* mutable_visibility_control();
  inline ::ProtoBuf::Panel_VisibilityControl* release_visibility_control();
  inline void set_allocated_visibility_control(::ProtoBuf::Panel_VisibilityControl* visibility_control);

  // optional .ProtoBuf.Panel.BlockCountControl block_count_control = 107;
  inline bool has_block_count_control() const;
  inline void clear_block_count_control();
  static const int kBlockCountControlFieldNumber = 107;
  inline const ::ProtoBuf::Panel_BlockCountControl& block_count_control() const;
  inline ::ProtoBuf::Panel_BlockCountControl* mutable_block_count_control();
  inline ::ProtoBuf::Panel_BlockCountControl* release_block_count_control();
  inline void set_allocated_block_count_control(::ProtoBuf::Panel_BlockCountControl* block_count_control);

  // optional .ProtoBuf.Panel.CellCountControl cell_count_control = 108;
  inline bool has_cell_count_control() const;
  inline void clear_cell_count_control();
  static const int kCellCountControlFieldNumber = 108;
  inline const ::ProtoBuf::Panel_CellCountControl& cell_count_control() const;
  inline ::ProtoBuf::Panel_CellCountControl* mutable_cell_count_control();
  inline ::ProtoBuf::Panel_CellCountControl* release_cell_count_control();
  inline void set_allocated_cell_count_control(::ProtoBuf::Panel_CellCountControl* cell_count_control);

  // optional .ProtoBuf.Panel.ProspectCountControl prospect_count_control = 109;
  inline bool has_prospect_count_control() const;
  inline void clear_prospect_count_control();
  static const int kProspectCountControlFieldNumber = 109;
  inline const ::ProtoBuf::Panel_ProspectCountControl& prospect_count_control() const;
  inline ::ProtoBuf::Panel_ProspectCountControl* mutable_prospect_count_control();
  inline ::ProtoBuf::Panel_ProspectCountControl* release_prospect_count_control();
  inline void set_allocated_prospect_count_control(::ProtoBuf::Panel_ProspectCountControl* prospect_count_control);

  // optional .ProtoBuf.Panel.CreationTimeControl creation_time_control = 110;
  inline bool has_creation_time_control() const;
  inline void clear_creation_time_control();
  static const int kCreationTimeControlFieldNumber = 110;
  inline const ::ProtoBuf::Panel_CreationTimeControl& creation_time_control() const;
  inline ::ProtoBuf::Panel_CreationTimeControl* mutable_creation_time_control();
  inline ::ProtoBuf::Panel_CreationTimeControl* release_creation_time_control();
  inline void set_allocated_creation_time_control(::ProtoBuf::Panel_CreationTimeControl* creation_time_control);

  // optional .ProtoBuf.Panel.LatestBlockTimeControl latest_block_time_control = 111;
  inline bool has_latest_block_time_control() const;
  inline void clear_latest_block_time_control();
  static const int kLatestBlockTimeControlFieldNumber = 111;
  inline const ::ProtoBuf::Panel_LatestBlockTimeControl& latest_block_time_control() const;
  inline ::ProtoBuf::Panel_LatestBlockTimeControl* mutable_latest_block_time_control();
  inline ::ProtoBuf::Panel_LatestBlockTimeControl* release_latest_block_time_control();
  inline void set_allocated_latest_block_time_control(::ProtoBuf::Panel_LatestBlockTimeControl* latest_block_time_control);

  // optional .ProtoBuf.Panel.LatestProspectTimeControl latest_prospect_time_control = 112;
  inline bool has_latest_prospect_time_control() const;
  inline void clear_latest_prospect_time_control();
  static const int kLatestProspectTimeControlFieldNumber = 112;
  inline const ::ProtoBuf::Panel_LatestProspectTimeControl& latest_prospect_time_control() const;
  inline ::ProtoBuf::Panel_LatestProspectTimeControl* mutable_latest_prospect_time_control();
  inline ::ProtoBuf::Panel_LatestProspectTimeControl* release_latest_prospect_time_control();
  inline void set_allocated_latest_prospect_time_control(::ProtoBuf::Panel_LatestProspectTimeControl* latest_prospect_time_control);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Panel)
 private:
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_study_name_control();
  inline void clear_has_study_name_control();
  inline void set_has_type_control();
  inline void clear_has_type_control();
  inline void set_has_status_control();
  inline void clear_has_status_control();
  inline void set_has_visibility_control();
  inline void clear_has_visibility_control();
  inline void set_has_block_count_control();
  inline void clear_has_block_count_control();
  inline void set_has_cell_count_control();
  inline void clear_has_cell_count_control();
  inline void set_has_prospect_count_control();
  inline void clear_has_prospect_count_control();
  inline void set_has_creation_time_control();
  inline void clear_has_creation_time_control();
  inline void set_has_latest_block_time_control();
  inline void clear_has_latest_block_time_control();
  inline void set_has_latest_prospect_time_control();
  inline void clear_has_latest_prospect_time_control();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::std::string* location_;
  ::ProtoBuf::Panel_StudyNameControl* study_name_control_;
  ::ProtoBuf::Panel_TypeControl* type_control_;
  ::ProtoBuf::Panel_StatusControl* status_control_;
  ::ProtoBuf::Panel_VisibilityControl* visibility_control_;
  ::ProtoBuf::Panel_BlockCountControl* block_count_control_;
  ::ProtoBuf::Panel_CellCountControl* cell_count_control_;
  ::ProtoBuf::Panel_ProspectCountControl* prospect_count_control_;
  ::ProtoBuf::Panel_CreationTimeControl* creation_time_control_;
  ::ProtoBuf::Panel_LatestBlockTimeControl* latest_block_time_control_;
  ::ProtoBuf::Panel_LatestProspectTimeControl* latest_prospect_time_control_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Panel* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string study_identifier = 1;
  inline bool has_study_identifier() const;
  inline void clear_study_identifier();
  static const int kStudyIdentifierFieldNumber = 1;
  inline const ::std::string& study_identifier() const;
  inline void set_study_identifier(const ::std::string& value);
  inline void set_study_identifier(const char* value);
  inline void set_study_identifier(const char* value, size_t size);
  inline ::std::string* mutable_study_identifier();
  inline ::std::string* release_study_identifier();
  inline void set_allocated_study_identifier(::std::string* study_identifier);

  // optional bool empty = 2 [default = true];
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 2;
  inline bool empty() const;
  inline void set_empty(bool value);

  // repeated .ProtoBuf.Predictor predictor = 3;
  inline int predictor_size() const;
  inline void clear_predictor();
  static const int kPredictorFieldNumber = 3;
  inline const ::ProtoBuf::Predictor& predictor(int index) const;
  inline ::ProtoBuf::Predictor* mutable_predictor(int index);
  inline ::ProtoBuf::Predictor* add_predictor();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Predictor >&
      predictor() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Predictor >*
      mutable_predictor();

  // repeated .ProtoBuf.Specimen specimen = 4;
  inline int specimen_size() const;
  inline void clear_specimen();
  static const int kSpecimenFieldNumber = 4;
  inline const ::ProtoBuf::Specimen& specimen(int index) const;
  inline ::ProtoBuf::Specimen* mutable_specimen(int index);
  inline ::ProtoBuf::Specimen* add_specimen();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Specimen >&
      specimen() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Specimen >*
      mutable_specimen();

  // @@protoc_insertion_point(class_scope:ProtoBuf.Block)
 private:
  inline void set_has_study_identifier();
  inline void clear_has_study_identifier();
  inline void set_has_empty();
  inline void clear_has_empty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* study_identifier_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Predictor > predictor_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Specimen > specimen_;
  bool empty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class Predictor : public ::google::protobuf::Message {
 public:
  Predictor();
  virtual ~Predictor();

  Predictor(const Predictor& from);

  inline Predictor& operator=(const Predictor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Predictor& default_instance();

  void Swap(Predictor* other);

  // implements Message ----------------------------------------------

  Predictor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Predictor& from);
  void MergeFrom(const Predictor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Predictor_Status Status;
  static const Status Active = Predictor_Status_Active;
  static const Status Inactive = Predictor_Status_Inactive;
  static inline bool Status_IsValid(int value) {
    return Predictor_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Predictor_Status_Status_MIN;
  static const Status Status_MAX =
    Predictor_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Predictor_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Predictor_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Predictor_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Predictor_Status_Parse(name, value);
  }

  typedef Predictor_Type Type;
  static const Type Categorical = Predictor_Type_Categorical;
  static const Type Continuous = Predictor_Type_Continuous;
  static inline bool Type_IsValid(int value) {
    return Predictor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Predictor_Type_Type_MIN;
  static const Type Type_MAX =
    Predictor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Predictor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Predictor_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Predictor_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Predictor_Type_Parse(name, value);
  }

  typedef Predictor_Level Level;
  static const Level Nominal = Predictor_Level_Nominal;
  static const Level Ordinal = Predictor_Level_Ordinal;
  static const Level Interval = Predictor_Level_Interval;
  static const Level Ratio = Predictor_Level_Ratio;
  static inline bool Level_IsValid(int value) {
    return Predictor_Level_IsValid(value);
  }
  static const Level Level_MIN =
    Predictor_Level_Level_MIN;
  static const Level Level_MAX =
    Predictor_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    Predictor_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return Predictor_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return Predictor_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return Predictor_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline ::google::protobuf::uint64 name() const;
  inline void set_name(::google::protobuf::uint64 value);

  // optional .ProtoBuf.Predictor.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::ProtoBuf::Predictor_Status status() const;
  inline void set_status(::ProtoBuf::Predictor_Status value);

  // optional .ProtoBuf.Predictor.Type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::ProtoBuf::Predictor_Type type() const;
  inline void set_type(::ProtoBuf::Predictor_Type value);

  // optional .ProtoBuf.Predictor.Level level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::ProtoBuf::Predictor_Level level() const;
  inline void set_level(::ProtoBuf::Predictor_Level value);

  // repeated .ProtoBuf.Cell cell = 5;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 5;
  inline const ::ProtoBuf::Cell& cell(int index) const;
  inline ::ProtoBuf::Cell* mutable_cell(int index);
  inline ::ProtoBuf::Cell* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >*
      mutable_cell();

  // @@protoc_insertion_point(class_scope:ProtoBuf.Predictor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 name_;
  int status_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell > cell_;
  int level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Predictor* default_instance_;
};
// -------------------------------------------------------------------

class Specimen : public ::google::protobuf::Message {
 public:
  Specimen();
  virtual ~Specimen();

  Specimen(const Specimen& from);

  inline Specimen& operator=(const Specimen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Specimen& default_instance();

  void Swap(Specimen* other);

  // implements Message ----------------------------------------------

  Specimen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Specimen& from);
  void MergeFrom(const Specimen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Specimen_Status Status;
  static const Status Active = Specimen_Status_Active;
  static const Status Inactive = Specimen_Status_Inactive;
  static inline bool Status_IsValid(int value) {
    return Specimen_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Specimen_Status_Status_MIN;
  static const Status Status_MAX =
    Specimen_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Specimen_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Specimen_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Specimen_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Specimen_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 key() const;
  inline void set_key(::google::protobuf::uint64 value);

  // optional .ProtoBuf.Specimen.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::ProtoBuf::Specimen_Status status() const;
  inline void set_status(::ProtoBuf::Specimen_Status value);

  // optional uint64 weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline ::google::protobuf::uint64 weight() const;
  inline void set_weight(::google::protobuf::uint64 value);

  // optional bool empty = 4 [default = true];
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 4;
  inline bool empty() const;
  inline void set_empty(bool value);

  // optional uint64 natural = 5;
  inline bool has_natural() const;
  inline void clear_natural();
  static const int kNaturalFieldNumber = 5;
  inline ::google::protobuf::uint64 natural() const;
  inline void set_natural(::google::protobuf::uint64 value);

  // optional sint64 integer = 6;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 6;
  inline ::google::protobuf::int64 integer() const;
  inline void set_integer(::google::protobuf::int64 value);

  // optional double real = 7;
  inline bool has_real() const;
  inline void clear_real();
  static const int kRealFieldNumber = 7;
  inline double real() const;
  inline void set_real(double value);

  // repeated .ProtoBuf.Cell cell = 8;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 8;
  inline const ::ProtoBuf::Cell& cell(int index) const;
  inline ::ProtoBuf::Cell* mutable_cell(int index);
  inline ::ProtoBuf::Cell* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >*
      mutable_cell();

  // @@protoc_insertion_point(class_scope:ProtoBuf.Specimen)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_empty();
  inline void clear_has_empty();
  inline void set_has_natural();
  inline void clear_has_natural();
  inline void set_has_integer();
  inline void clear_has_integer();
  inline void set_has_real();
  inline void clear_has_real();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 key_;
  ::google::protobuf::uint64 weight_;
  int status_;
  bool empty_;
  ::google::protobuf::uint64 natural_;
  ::google::protobuf::int64 integer_;
  double real_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell > cell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Specimen* default_instance_;
};
// -------------------------------------------------------------------

class Cell : public ::google::protobuf::Message {
 public:
  Cell();
  virtual ~Cell();

  Cell(const Cell& from);

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell& default_instance();

  void Swap(Cell* other);

  // implements Message ----------------------------------------------

  Cell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline ::google::protobuf::uint64 name() const;
  inline void set_name(::google::protobuf::uint64 value);

  // optional uint64 key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 key() const;
  inline void set_key(::google::protobuf::uint64 value);

  // optional bool empty = 3 [default = true];
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 3;
  inline bool empty() const;
  inline void set_empty(bool value);

  // optional uint64 natural = 4;
  inline bool has_natural() const;
  inline void clear_natural();
  static const int kNaturalFieldNumber = 4;
  inline ::google::protobuf::uint64 natural() const;
  inline void set_natural(::google::protobuf::uint64 value);

  // optional sint64 integer = 5;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 5;
  inline ::google::protobuf::int64 integer() const;
  inline void set_integer(::google::protobuf::int64 value);

  // optional double real = 6;
  inline bool has_real() const;
  inline void clear_real();
  static const int kRealFieldNumber = 6;
  inline double real() const;
  inline void set_real(double value);

  // optional uint64 special = 7;
  inline bool has_special() const;
  inline void clear_special();
  static const int kSpecialFieldNumber = 7;
  inline ::google::protobuf::uint64 special() const;
  inline void set_special(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Cell)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_empty();
  inline void clear_has_empty();
  inline void set_has_natural();
  inline void clear_has_natural();
  inline void set_has_integer();
  inline void clear_has_integer();
  inline void set_has_real();
  inline void clear_has_real();
  inline void set_has_special();
  inline void clear_has_special();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 name_;
  ::google::protobuf::uint64 key_;
  ::google::protobuf::uint64 natural_;
  ::google::protobuf::int64 integer_;
  double real_;
  ::google::protobuf::uint64 special_;
  bool empty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Cell* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static const Type Information = Message_Type_Information;
  static const Type Error = Message_Type_Error;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ProtoBuf.Message.Type type = 101;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 101;
  inline ::ProtoBuf::Message_Type type() const;
  inline void set_type(::ProtoBuf::Message_Type value);

  // optional string text = 102;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 102;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ProtoBuf.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yosokumo_2eproto();
  friend void protobuf_AssignDesc_yosokumo_2eproto();
  friend void protobuf_ShutdownFile_yosokumo_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Catalog

// required string user_identifier = 1;
inline bool Catalog::has_user_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Catalog::set_has_user_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Catalog::clear_has_user_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Catalog::clear_user_identifier() {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    user_identifier_->clear();
  }
  clear_has_user_identifier();
}
inline const ::std::string& Catalog::user_identifier() const {
  return *user_identifier_;
}
inline void Catalog::set_user_identifier(const ::std::string& value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Catalog::set_user_identifier(const char* value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Catalog::set_user_identifier(const char* value, size_t size) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Catalog::mutable_user_identifier() {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  return user_identifier_;
}
inline ::std::string* Catalog::release_user_identifier() {
  clear_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_identifier_;
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Catalog::set_allocated_user_identifier(::std::string* user_identifier) {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete user_identifier_;
  }
  if (user_identifier) {
    set_has_user_identifier();
    user_identifier_ = user_identifier;
  } else {
    clear_has_user_identifier();
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 102;
inline bool Catalog::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Catalog::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Catalog::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Catalog::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& Catalog::user_name() const {
  return *user_name_;
}
inline void Catalog::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Catalog::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Catalog::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Catalog::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* Catalog::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Catalog::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 103;
inline bool Catalog::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Catalog::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Catalog::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Catalog::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Catalog::location() const {
  return *location_;
}
inline void Catalog::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Catalog::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Catalog::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Catalog::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Catalog::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Catalog::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoBuf.Study study = 4;
inline int Catalog::study_size() const {
  return study_.size();
}
inline void Catalog::clear_study() {
  study_.Clear();
}
inline const ::ProtoBuf::Study& Catalog::study(int index) const {
  return study_.Get(index);
}
inline ::ProtoBuf::Study* Catalog::mutable_study(int index) {
  return study_.Mutable(index);
}
inline ::ProtoBuf::Study* Catalog::add_study() {
  return study_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Study >&
Catalog::study() const {
  return study_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Study >*
Catalog::mutable_study() {
  return &study_;
}

// -------------------------------------------------------------------

// Study_Owner

// required string user_identifier = 1;
inline bool Study_Owner::has_user_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study_Owner::set_has_user_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study_Owner::clear_has_user_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study_Owner::clear_user_identifier() {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    user_identifier_->clear();
  }
  clear_has_user_identifier();
}
inline const ::std::string& Study_Owner::user_identifier() const {
  return *user_identifier_;
}
inline void Study_Owner::set_user_identifier(const ::std::string& value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Study_Owner::set_user_identifier(const char* value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Study_Owner::set_user_identifier(const char* value, size_t size) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Owner::mutable_user_identifier() {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  return user_identifier_;
}
inline ::std::string* Study_Owner::release_user_identifier() {
  clear_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_identifier_;
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Owner::set_allocated_user_identifier(::std::string* user_identifier) {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete user_identifier_;
  }
  if (user_identifier) {
    set_has_user_identifier();
    user_identifier_ = user_identifier;
  } else {
    clear_has_user_identifier();
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 102;
inline bool Study_Owner::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Study_Owner::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Study_Owner::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Study_Owner::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& Study_Owner::user_name() const {
  return *user_name_;
}
inline void Study_Owner::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Study_Owner::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Study_Owner::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Owner::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* Study_Owner::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Owner::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Study_Table

// optional string location = 101;
inline bool Study_Table::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study_Table::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study_Table::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study_Table::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Study_Table::location() const {
  return *location_;
}
inline void Study_Table::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Table::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Table::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Table::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Study_Table::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Table::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Study_Model

// optional string location = 101;
inline bool Study_Model::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study_Model::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study_Model::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study_Model::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Study_Model::location() const {
  return *location_;
}
inline void Study_Model::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Model::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Model::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Model::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Study_Model::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Model::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Study_Panel

// optional string location = 101;
inline bool Study_Panel::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study_Panel::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study_Panel::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study_Panel::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Study_Panel::location() const {
  return *location_;
}
inline void Study_Panel::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Panel::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Panel::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Panel::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Study_Panel::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Panel::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Study_Roster

// optional string location = 101;
inline bool Study_Roster::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study_Roster::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study_Roster::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study_Roster::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Study_Roster::location() const {
  return *location_;
}
inline void Study_Roster::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Roster::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study_Roster::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study_Roster::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Study_Roster::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study_Roster::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Study

// required string study_identifier = 1;
inline bool Study::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Study::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Study::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Study::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Study::study_identifier() const {
  return *study_identifier_;
}
inline void Study::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Study::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Study::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Study::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_name = 102;
inline bool Study::has_study_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Study::set_has_study_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Study::clear_has_study_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Study::clear_study_name() {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    study_name_->clear();
  }
  clear_has_study_name();
}
inline const ::std::string& Study::study_name() const {
  return *study_name_;
}
inline void Study::set_study_name(const ::std::string& value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Study::set_study_name(const char* value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Study::set_study_name(const char* value, size_t size) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study::mutable_study_name() {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  return study_name_;
}
inline ::std::string* Study::release_study_name() {
  clear_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_name_;
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study::set_allocated_study_name(::std::string* study_name) {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    delete study_name_;
  }
  if (study_name) {
    set_has_study_name();
    study_name_ = study_name;
  } else {
    clear_has_study_name();
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ProtoBuf.Study.Type type = 103;
inline bool Study::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Study::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Study::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Study::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::Study_Type Study::type() const {
  return static_cast< ::ProtoBuf::Study_Type >(type_);
}
inline void Study::set_type(::ProtoBuf::Study_Type value) {
  assert(::ProtoBuf::Study_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .ProtoBuf.Study.Status status = 104;
inline bool Study::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Study::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Study::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Study::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::ProtoBuf::Study_Status Study::status() const {
  return static_cast< ::ProtoBuf::Study_Status >(status_);
}
inline void Study::set_status(::ProtoBuf::Study_Status value) {
  assert(::ProtoBuf::Study_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .ProtoBuf.Study.Visibility visibility = 105;
inline bool Study::has_visibility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Study::set_has_visibility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Study::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Study::clear_visibility() {
  visibility_ = 1;
  clear_has_visibility();
}
inline ::ProtoBuf::Study_Visibility Study::visibility() const {
  return static_cast< ::ProtoBuf::Study_Visibility >(visibility_);
}
inline void Study::set_visibility(::ProtoBuf::Study_Visibility value) {
  assert(::ProtoBuf::Study_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
}

// optional string location = 106;
inline bool Study::has_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Study::set_has_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Study::clear_has_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Study::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Study::location() const {
  return *location_;
}
inline void Study::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Study::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Study::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Study::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Study::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ProtoBuf.Study.Owner owner = 107;
inline bool Study::has_owner() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Study::set_has_owner() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Study::clear_has_owner() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Study::clear_owner() {
  if (owner_ != NULL) owner_->::ProtoBuf::Study_Owner::Clear();
  clear_has_owner();
}
inline const ::ProtoBuf::Study_Owner& Study::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::ProtoBuf::Study_Owner* Study::mutable_owner() {
  set_has_owner();
  if (owner_ == NULL) owner_ = new ::ProtoBuf::Study_Owner;
  return owner_;
}
inline ::ProtoBuf::Study_Owner* Study::release_owner() {
  clear_has_owner();
  ::ProtoBuf::Study_Owner* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline void Study::set_allocated_owner(::ProtoBuf::Study_Owner* owner) {
  delete owner_;
  owner_ = owner;
  if (owner) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
}

// optional .ProtoBuf.Study.Table table = 108;
inline bool Study::has_table() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Study::set_has_table() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Study::clear_has_table() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Study::clear_table() {
  if (table_ != NULL) table_->::ProtoBuf::Study_Table::Clear();
  clear_has_table();
}
inline const ::ProtoBuf::Study_Table& Study::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::ProtoBuf::Study_Table* Study::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::ProtoBuf::Study_Table;
  return table_;
}
inline ::ProtoBuf::Study_Table* Study::release_table() {
  clear_has_table();
  ::ProtoBuf::Study_Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void Study::set_allocated_table(::ProtoBuf::Study_Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// optional .ProtoBuf.Study.Model model = 109;
inline bool Study::has_model() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Study::set_has_model() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Study::clear_has_model() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Study::clear_model() {
  if (model_ != NULL) model_->::ProtoBuf::Study_Model::Clear();
  clear_has_model();
}
inline const ::ProtoBuf::Study_Model& Study::model() const {
  return model_ != NULL ? *model_ : *default_instance_->model_;
}
inline ::ProtoBuf::Study_Model* Study::mutable_model() {
  set_has_model();
  if (model_ == NULL) model_ = new ::ProtoBuf::Study_Model;
  return model_;
}
inline ::ProtoBuf::Study_Model* Study::release_model() {
  clear_has_model();
  ::ProtoBuf::Study_Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline void Study::set_allocated_model(::ProtoBuf::Study_Model* model) {
  delete model_;
  model_ = model;
  if (model) {
    set_has_model();
  } else {
    clear_has_model();
  }
}

// optional .ProtoBuf.Study.Panel panel = 110;
inline bool Study::has_panel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Study::set_has_panel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Study::clear_has_panel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Study::clear_panel() {
  if (panel_ != NULL) panel_->::ProtoBuf::Study_Panel::Clear();
  clear_has_panel();
}
inline const ::ProtoBuf::Study_Panel& Study::panel() const {
  return panel_ != NULL ? *panel_ : *default_instance_->panel_;
}
inline ::ProtoBuf::Study_Panel* Study::mutable_panel() {
  set_has_panel();
  if (panel_ == NULL) panel_ = new ::ProtoBuf::Study_Panel;
  return panel_;
}
inline ::ProtoBuf::Study_Panel* Study::release_panel() {
  clear_has_panel();
  ::ProtoBuf::Study_Panel* temp = panel_;
  panel_ = NULL;
  return temp;
}
inline void Study::set_allocated_panel(::ProtoBuf::Study_Panel* panel) {
  delete panel_;
  panel_ = panel;
  if (panel) {
    set_has_panel();
  } else {
    clear_has_panel();
  }
}

// optional .ProtoBuf.Study.Roster roster = 111;
inline bool Study::has_roster() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Study::set_has_roster() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Study::clear_has_roster() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Study::clear_roster() {
  if (roster_ != NULL) roster_->::ProtoBuf::Study_Roster::Clear();
  clear_has_roster();
}
inline const ::ProtoBuf::Study_Roster& Study::roster() const {
  return roster_ != NULL ? *roster_ : *default_instance_->roster_;
}
inline ::ProtoBuf::Study_Roster* Study::mutable_roster() {
  set_has_roster();
  if (roster_ == NULL) roster_ = new ::ProtoBuf::Study_Roster;
  return roster_;
}
inline ::ProtoBuf::Study_Roster* Study::release_roster() {
  clear_has_roster();
  ::ProtoBuf::Study_Roster* temp = roster_;
  roster_ = NULL;
  return temp;
}
inline void Study::set_allocated_roster(::ProtoBuf::Study_Roster* roster) {
  delete roster_;
  roster_ = roster;
  if (roster) {
    set_has_roster();
  } else {
    clear_has_roster();
  }
}

// -------------------------------------------------------------------

// Roster

// required string study_identifier = 1;
inline bool Roster::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Roster::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Roster::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Roster::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Roster::study_identifier() const {
  return *study_identifier_;
}
inline void Roster::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Roster::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Roster::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Roster::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Roster::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Roster::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_name = 102;
inline bool Roster::has_study_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Roster::set_has_study_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Roster::clear_has_study_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Roster::clear_study_name() {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    study_name_->clear();
  }
  clear_has_study_name();
}
inline const ::std::string& Roster::study_name() const {
  return *study_name_;
}
inline void Roster::set_study_name(const ::std::string& value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Roster::set_study_name(const char* value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Roster::set_study_name(const char* value, size_t size) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Roster::mutable_study_name() {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  return study_name_;
}
inline ::std::string* Roster::release_study_name() {
  clear_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_name_;
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Roster::set_allocated_study_name(::std::string* study_name) {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    delete study_name_;
  }
  if (study_name) {
    set_has_study_name();
    study_name_ = study_name;
  } else {
    clear_has_study_name();
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 103;
inline bool Roster::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Roster::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Roster::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Roster::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Roster::location() const {
  return *location_;
}
inline void Roster::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Roster::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Roster::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Roster::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Roster::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Roster::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoBuf.Role role = 4;
inline int Roster::role_size() const {
  return role_.size();
}
inline void Roster::clear_role() {
  role_.Clear();
}
inline const ::ProtoBuf::Role& Roster::role(int index) const {
  return role_.Get(index);
}
inline ::ProtoBuf::Role* Roster::mutable_role(int index) {
  return role_.Mutable(index);
}
inline ::ProtoBuf::Role* Roster::add_role() {
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Role >&
Roster::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Role >*
Roster::mutable_role() {
  return &role_;
}

// -------------------------------------------------------------------

// Role_Roleholder

// required string user_identifier = 1;
inline bool Role_Roleholder::has_user_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_Roleholder::set_has_user_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_Roleholder::clear_has_user_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_Roleholder::clear_user_identifier() {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    user_identifier_->clear();
  }
  clear_has_user_identifier();
}
inline const ::std::string& Role_Roleholder::user_identifier() const {
  return *user_identifier_;
}
inline void Role_Roleholder::set_user_identifier(const ::std::string& value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Role_Roleholder::set_user_identifier(const char* value) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(value);
}
inline void Role_Roleholder::set_user_identifier(const char* value, size_t size) {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  user_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role_Roleholder::mutable_user_identifier() {
  set_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    user_identifier_ = new ::std::string;
  }
  return user_identifier_;
}
inline ::std::string* Role_Roleholder::release_user_identifier() {
  clear_has_user_identifier();
  if (user_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_identifier_;
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role_Roleholder::set_allocated_user_identifier(::std::string* user_identifier) {
  if (user_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete user_identifier_;
  }
  if (user_identifier) {
    set_has_user_identifier();
    user_identifier_ = user_identifier;
  } else {
    clear_has_user_identifier();
    user_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 102;
inline bool Role_Roleholder::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role_Roleholder::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role_Roleholder::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role_Roleholder::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& Role_Roleholder::user_name() const {
  return *user_name_;
}
inline void Role_Roleholder::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Role_Roleholder::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void Role_Roleholder::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role_Roleholder::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* Role_Roleholder::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role_Roleholder::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Role_Privileges

// optional bool get_study = 1;
inline bool Role_Privileges::has_get_study() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_Privileges::set_has_get_study() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_Privileges::clear_has_get_study() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_Privileges::clear_get_study() {
  get_study_ = false;
  clear_has_get_study();
}
inline bool Role_Privileges::get_study() const {
  return get_study_;
}
inline void Role_Privileges::set_get_study(bool value) {
  set_has_get_study();
  get_study_ = value;
}

// optional bool delete_study = 2;
inline bool Role_Privileges::has_delete_study() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role_Privileges::set_has_delete_study() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role_Privileges::clear_has_delete_study() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role_Privileges::clear_delete_study() {
  delete_study_ = false;
  clear_has_delete_study();
}
inline bool Role_Privileges::delete_study() const {
  return delete_study_;
}
inline void Role_Privileges::set_delete_study(bool value) {
  set_has_delete_study();
  delete_study_ = value;
}

// optional bool get_roster = 3;
inline bool Role_Privileges::has_get_roster() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role_Privileges::set_has_get_roster() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role_Privileges::clear_has_get_roster() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role_Privileges::clear_get_roster() {
  get_roster_ = false;
  clear_has_get_roster();
}
inline bool Role_Privileges::get_roster() const {
  return get_roster_;
}
inline void Role_Privileges::set_get_roster(bool value) {
  set_has_get_roster();
  get_roster_ = value;
}

// optional bool post_roster = 4;
inline bool Role_Privileges::has_post_roster() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role_Privileges::set_has_post_roster() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role_Privileges::clear_has_post_roster() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role_Privileges::clear_post_roster() {
  post_roster_ = false;
  clear_has_post_roster();
}
inline bool Role_Privileges::post_roster() const {
  return post_roster_;
}
inline void Role_Privileges::set_post_roster(bool value) {
  set_has_post_roster();
  post_roster_ = value;
}

// optional bool get_role = 5;
inline bool Role_Privileges::has_get_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role_Privileges::set_has_get_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role_Privileges::clear_has_get_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role_Privileges::clear_get_role() {
  get_role_ = false;
  clear_has_get_role();
}
inline bool Role_Privileges::get_role() const {
  return get_role_;
}
inline void Role_Privileges::set_get_role(bool value) {
  set_has_get_role();
  get_role_ = value;
}

// optional bool put_role = 6;
inline bool Role_Privileges::has_put_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Role_Privileges::set_has_put_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Role_Privileges::clear_has_put_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Role_Privileges::clear_put_role() {
  put_role_ = false;
  clear_has_put_role();
}
inline bool Role_Privileges::put_role() const {
  return put_role_;
}
inline void Role_Privileges::set_put_role(bool value) {
  set_has_put_role();
  put_role_ = value;
}

// optional bool delete_role = 7;
inline bool Role_Privileges::has_delete_role() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Role_Privileges::set_has_delete_role() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Role_Privileges::clear_has_delete_role() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Role_Privileges::clear_delete_role() {
  delete_role_ = false;
  clear_has_delete_role();
}
inline bool Role_Privileges::delete_role() const {
  return delete_role_;
}
inline void Role_Privileges::set_delete_role(bool value) {
  set_has_delete_role();
  delete_role_ = value;
}

// optional bool get_panel = 8;
inline bool Role_Privileges::has_get_panel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Role_Privileges::set_has_get_panel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Role_Privileges::clear_has_get_panel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Role_Privileges::clear_get_panel() {
  get_panel_ = false;
  clear_has_get_panel();
}
inline bool Role_Privileges::get_panel() const {
  return get_panel_;
}
inline void Role_Privileges::set_get_panel(bool value) {
  set_has_get_panel();
  get_panel_ = value;
}

// optional bool get_control = 9;
inline bool Role_Privileges::has_get_control() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Role_Privileges::set_has_get_control() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Role_Privileges::clear_has_get_control() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Role_Privileges::clear_get_control() {
  get_control_ = false;
  clear_has_get_control();
}
inline bool Role_Privileges::get_control() const {
  return get_control_;
}
inline void Role_Privileges::set_get_control(bool value) {
  set_has_get_control();
  get_control_ = value;
}

// optional bool put_control = 10;
inline bool Role_Privileges::has_put_control() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Role_Privileges::set_has_put_control() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Role_Privileges::clear_has_put_control() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Role_Privileges::clear_put_control() {
  put_control_ = false;
  clear_has_put_control();
}
inline bool Role_Privileges::put_control() const {
  return put_control_;
}
inline void Role_Privileges::set_put_control(bool value) {
  set_has_put_control();
  put_control_ = value;
}

// optional bool post_table = 11;
inline bool Role_Privileges::has_post_table() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Role_Privileges::set_has_post_table() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Role_Privileges::clear_has_post_table() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Role_Privileges::clear_post_table() {
  post_table_ = false;
  clear_has_post_table();
}
inline bool Role_Privileges::post_table() const {
  return post_table_;
}
inline void Role_Privileges::set_post_table(bool value) {
  set_has_post_table();
  post_table_ = value;
}

// optional bool get_model = 12;
inline bool Role_Privileges::has_get_model() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Role_Privileges::set_has_get_model() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Role_Privileges::clear_has_get_model() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Role_Privileges::clear_get_model() {
  get_model_ = false;
  clear_has_get_model();
}
inline bool Role_Privileges::get_model() const {
  return get_model_;
}
inline void Role_Privileges::set_get_model(bool value) {
  set_has_get_model();
  get_model_ = value;
}

// optional bool post_model = 13;
inline bool Role_Privileges::has_post_model() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Role_Privileges::set_has_post_model() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Role_Privileges::clear_has_post_model() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Role_Privileges::clear_post_model() {
  post_model_ = false;
  clear_has_post_model();
}
inline bool Role_Privileges::post_model() const {
  return post_model_;
}
inline void Role_Privileges::set_post_model(bool value) {
  set_has_post_model();
  post_model_ = value;
}

// -------------------------------------------------------------------

// Role_Study

// required string study_identifier = 1;
inline bool Role_Study::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_Study::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_Study::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_Study::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Role_Study::study_identifier() const {
  return *study_identifier_;
}
inline void Role_Study::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Role_Study::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Role_Study::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role_Study::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Role_Study::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role_Study::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_name = 102;
inline bool Role_Study::has_study_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role_Study::set_has_study_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role_Study::clear_has_study_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role_Study::clear_study_name() {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    study_name_->clear();
  }
  clear_has_study_name();
}
inline const ::std::string& Role_Study::study_name() const {
  return *study_name_;
}
inline void Role_Study::set_study_name(const ::std::string& value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Role_Study::set_study_name(const char* value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Role_Study::set_study_name(const char* value, size_t size) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role_Study::mutable_study_name() {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  return study_name_;
}
inline ::std::string* Role_Study::release_study_name() {
  clear_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_name_;
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role_Study::set_allocated_study_name(::std::string* study_name) {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    delete study_name_;
  }
  if (study_name) {
    set_has_study_name();
    study_name_ = study_name;
  } else {
    clear_has_study_name();
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Role

// optional string location = 101;
inline bool Role::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Role::location() const {
  return *location_;
}
inline void Role::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Role::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Role::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Role::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ProtoBuf.Role.Roleholder roleholder = 102;
inline bool Role::has_roleholder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_roleholder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_roleholder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_roleholder() {
  if (roleholder_ != NULL) roleholder_->::ProtoBuf::Role_Roleholder::Clear();
  clear_has_roleholder();
}
inline const ::ProtoBuf::Role_Roleholder& Role::roleholder() const {
  return roleholder_ != NULL ? *roleholder_ : *default_instance_->roleholder_;
}
inline ::ProtoBuf::Role_Roleholder* Role::mutable_roleholder() {
  set_has_roleholder();
  if (roleholder_ == NULL) roleholder_ = new ::ProtoBuf::Role_Roleholder;
  return roleholder_;
}
inline ::ProtoBuf::Role_Roleholder* Role::release_roleholder() {
  clear_has_roleholder();
  ::ProtoBuf::Role_Roleholder* temp = roleholder_;
  roleholder_ = NULL;
  return temp;
}
inline void Role::set_allocated_roleholder(::ProtoBuf::Role_Roleholder* roleholder) {
  delete roleholder_;
  roleholder_ = roleholder;
  if (roleholder) {
    set_has_roleholder();
  } else {
    clear_has_roleholder();
  }
}

// optional .ProtoBuf.Role.Privileges privileges = 103;
inline bool Role::has_privileges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role::set_has_privileges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role::clear_has_privileges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role::clear_privileges() {
  if (privileges_ != NULL) privileges_->::ProtoBuf::Role_Privileges::Clear();
  clear_has_privileges();
}
inline const ::ProtoBuf::Role_Privileges& Role::privileges() const {
  return privileges_ != NULL ? *privileges_ : *default_instance_->privileges_;
}
inline ::ProtoBuf::Role_Privileges* Role::mutable_privileges() {
  set_has_privileges();
  if (privileges_ == NULL) privileges_ = new ::ProtoBuf::Role_Privileges;
  return privileges_;
}
inline ::ProtoBuf::Role_Privileges* Role::release_privileges() {
  clear_has_privileges();
  ::ProtoBuf::Role_Privileges* temp = privileges_;
  privileges_ = NULL;
  return temp;
}
inline void Role::set_allocated_privileges(::ProtoBuf::Role_Privileges* privileges) {
  delete privileges_;
  privileges_ = privileges;
  if (privileges) {
    set_has_privileges();
  } else {
    clear_has_privileges();
  }
}

// optional .ProtoBuf.Role.Study study = 104;
inline bool Role::has_study() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role::set_has_study() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role::clear_has_study() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role::clear_study() {
  if (study_ != NULL) study_->::ProtoBuf::Role_Study::Clear();
  clear_has_study();
}
inline const ::ProtoBuf::Role_Study& Role::study() const {
  return study_ != NULL ? *study_ : *default_instance_->study_;
}
inline ::ProtoBuf::Role_Study* Role::mutable_study() {
  set_has_study();
  if (study_ == NULL) study_ = new ::ProtoBuf::Role_Study;
  return study_;
}
inline ::ProtoBuf::Role_Study* Role::release_study() {
  clear_has_study();
  ::ProtoBuf::Role_Study* temp = study_;
  study_ = NULL;
  return temp;
}
inline void Role::set_allocated_study(::ProtoBuf::Role_Study* study) {
  delete study_;
  study_ = study;
  if (study) {
    set_has_study();
  } else {
    clear_has_study();
  }
}

// -------------------------------------------------------------------

// Panel_StudyNameControl

// required string study_name = 1;
inline bool Panel_StudyNameControl::has_study_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_StudyNameControl::set_has_study_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_StudyNameControl::clear_has_study_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_StudyNameControl::clear_study_name() {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    study_name_->clear();
  }
  clear_has_study_name();
}
inline const ::std::string& Panel_StudyNameControl::study_name() const {
  return *study_name_;
}
inline void Panel_StudyNameControl::set_study_name(const ::std::string& value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Panel_StudyNameControl::set_study_name(const char* value) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(value);
}
inline void Panel_StudyNameControl::set_study_name(const char* value, size_t size) {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  study_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_StudyNameControl::mutable_study_name() {
  set_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    study_name_ = new ::std::string;
  }
  return study_name_;
}
inline ::std::string* Panel_StudyNameControl::release_study_name() {
  clear_has_study_name();
  if (study_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_name_;
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_StudyNameControl::set_allocated_study_name(::std::string* study_name) {
  if (study_name_ != &::google::protobuf::internal::kEmptyString) {
    delete study_name_;
  }
  if (study_name) {
    set_has_study_name();
    study_name_ = study_name;
  } else {
    clear_has_study_name();
    study_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_identifier = 102;
inline bool Panel_StudyNameControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_StudyNameControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_StudyNameControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_StudyNameControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_StudyNameControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_StudyNameControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_StudyNameControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_StudyNameControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_StudyNameControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_StudyNameControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_StudyNameControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 103;
inline bool Panel_StudyNameControl::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Panel_StudyNameControl::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Panel_StudyNameControl::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Panel_StudyNameControl::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Panel_StudyNameControl::location() const {
  return *location_;
}
inline void Panel_StudyNameControl::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_StudyNameControl::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_StudyNameControl::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_StudyNameControl::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Panel_StudyNameControl::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_StudyNameControl::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_TypeControl

// required .ProtoBuf.Study.Type type = 1;
inline bool Panel_TypeControl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_TypeControl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_TypeControl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_TypeControl::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::Study_Type Panel_TypeControl::type() const {
  return static_cast< ::ProtoBuf::Study_Type >(type_);
}
inline void Panel_TypeControl::set_type(::ProtoBuf::Study_Type value) {
  assert(::ProtoBuf::Study_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_TypeControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_TypeControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_TypeControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_TypeControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_TypeControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_TypeControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_TypeControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_TypeControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_TypeControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_TypeControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_TypeControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_StatusControl

// required .ProtoBuf.Study.Status status = 1;
inline bool Panel_StatusControl::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_StatusControl::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_StatusControl::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_StatusControl::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::ProtoBuf::Study_Status Panel_StatusControl::status() const {
  return static_cast< ::ProtoBuf::Study_Status >(status_);
}
inline void Panel_StatusControl::set_status(::ProtoBuf::Study_Status value) {
  assert(::ProtoBuf::Study_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_StatusControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_StatusControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_StatusControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_StatusControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_StatusControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_StatusControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_StatusControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_StatusControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_StatusControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_StatusControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_StatusControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 103;
inline bool Panel_StatusControl::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Panel_StatusControl::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Panel_StatusControl::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Panel_StatusControl::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Panel_StatusControl::location() const {
  return *location_;
}
inline void Panel_StatusControl::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_StatusControl::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_StatusControl::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_StatusControl::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Panel_StatusControl::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_StatusControl::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_VisibilityControl

// required .ProtoBuf.Study.Visibility visibility = 1;
inline bool Panel_VisibilityControl::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_VisibilityControl::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_VisibilityControl::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_VisibilityControl::clear_visibility() {
  visibility_ = 1;
  clear_has_visibility();
}
inline ::ProtoBuf::Study_Visibility Panel_VisibilityControl::visibility() const {
  return static_cast< ::ProtoBuf::Study_Visibility >(visibility_);
}
inline void Panel_VisibilityControl::set_visibility(::ProtoBuf::Study_Visibility value) {
  assert(::ProtoBuf::Study_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_VisibilityControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_VisibilityControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_VisibilityControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_VisibilityControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_VisibilityControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_VisibilityControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_VisibilityControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_VisibilityControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_VisibilityControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_VisibilityControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_VisibilityControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 103;
inline bool Panel_VisibilityControl::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Panel_VisibilityControl::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Panel_VisibilityControl::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Panel_VisibilityControl::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Panel_VisibilityControl::location() const {
  return *location_;
}
inline void Panel_VisibilityControl::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_VisibilityControl::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel_VisibilityControl::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_VisibilityControl::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Panel_VisibilityControl::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_VisibilityControl::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_BlockCountControl

// required uint64 block_count = 1;
inline bool Panel_BlockCountControl::has_block_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_BlockCountControl::set_has_block_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_BlockCountControl::clear_has_block_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_BlockCountControl::clear_block_count() {
  block_count_ = GOOGLE_ULONGLONG(0);
  clear_has_block_count();
}
inline ::google::protobuf::uint64 Panel_BlockCountControl::block_count() const {
  return block_count_;
}
inline void Panel_BlockCountControl::set_block_count(::google::protobuf::uint64 value) {
  set_has_block_count();
  block_count_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_BlockCountControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_BlockCountControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_BlockCountControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_BlockCountControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_BlockCountControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_BlockCountControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_BlockCountControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_BlockCountControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_BlockCountControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_BlockCountControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_BlockCountControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_CellCountControl

// required uint64 cell_count = 1;
inline bool Panel_CellCountControl::has_cell_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_CellCountControl::set_has_cell_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_CellCountControl::clear_has_cell_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_CellCountControl::clear_cell_count() {
  cell_count_ = GOOGLE_ULONGLONG(0);
  clear_has_cell_count();
}
inline ::google::protobuf::uint64 Panel_CellCountControl::cell_count() const {
  return cell_count_;
}
inline void Panel_CellCountControl::set_cell_count(::google::protobuf::uint64 value) {
  set_has_cell_count();
  cell_count_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_CellCountControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_CellCountControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_CellCountControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_CellCountControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_CellCountControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_CellCountControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_CellCountControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_CellCountControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_CellCountControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_CellCountControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_CellCountControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_ProspectCountControl

// required uint64 prospect_count = 1;
inline bool Panel_ProspectCountControl::has_prospect_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_ProspectCountControl::set_has_prospect_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_ProspectCountControl::clear_has_prospect_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_ProspectCountControl::clear_prospect_count() {
  prospect_count_ = GOOGLE_ULONGLONG(0);
  clear_has_prospect_count();
}
inline ::google::protobuf::uint64 Panel_ProspectCountControl::prospect_count() const {
  return prospect_count_;
}
inline void Panel_ProspectCountControl::set_prospect_count(::google::protobuf::uint64 value) {
  set_has_prospect_count();
  prospect_count_ = value;
}

// optional string study_identifier = 102;
inline bool Panel_ProspectCountControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_ProspectCountControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_ProspectCountControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_ProspectCountControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_ProspectCountControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_ProspectCountControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_ProspectCountControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_ProspectCountControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_ProspectCountControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_ProspectCountControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_ProspectCountControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_CreationTimeControl

// required string creation_time = 1;
inline bool Panel_CreationTimeControl::has_creation_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_CreationTimeControl::set_has_creation_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_CreationTimeControl::clear_has_creation_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_CreationTimeControl::clear_creation_time() {
  if (creation_time_ != &::google::protobuf::internal::kEmptyString) {
    creation_time_->clear();
  }
  clear_has_creation_time();
}
inline const ::std::string& Panel_CreationTimeControl::creation_time() const {
  return *creation_time_;
}
inline void Panel_CreationTimeControl::set_creation_time(const ::std::string& value) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::kEmptyString) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void Panel_CreationTimeControl::set_creation_time(const char* value) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::kEmptyString) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void Panel_CreationTimeControl::set_creation_time(const char* value, size_t size) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::kEmptyString) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_CreationTimeControl::mutable_creation_time() {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::kEmptyString) {
    creation_time_ = new ::std::string;
  }
  return creation_time_;
}
inline ::std::string* Panel_CreationTimeControl::release_creation_time() {
  clear_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creation_time_;
    creation_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_CreationTimeControl::set_allocated_creation_time(::std::string* creation_time) {
  if (creation_time_ != &::google::protobuf::internal::kEmptyString) {
    delete creation_time_;
  }
  if (creation_time) {
    set_has_creation_time();
    creation_time_ = creation_time;
  } else {
    clear_has_creation_time();
    creation_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_identifier = 102;
inline bool Panel_CreationTimeControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_CreationTimeControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_CreationTimeControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_CreationTimeControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_CreationTimeControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_CreationTimeControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_CreationTimeControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_CreationTimeControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_CreationTimeControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_CreationTimeControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_CreationTimeControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_LatestBlockTimeControl

// required string latest_block_time = 1;
inline bool Panel_LatestBlockTimeControl::has_latest_block_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_LatestBlockTimeControl::set_has_latest_block_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_LatestBlockTimeControl::clear_has_latest_block_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_LatestBlockTimeControl::clear_latest_block_time() {
  if (latest_block_time_ != &::google::protobuf::internal::kEmptyString) {
    latest_block_time_->clear();
  }
  clear_has_latest_block_time();
}
inline const ::std::string& Panel_LatestBlockTimeControl::latest_block_time() const {
  return *latest_block_time_;
}
inline void Panel_LatestBlockTimeControl::set_latest_block_time(const ::std::string& value) {
  set_has_latest_block_time();
  if (latest_block_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_block_time_ = new ::std::string;
  }
  latest_block_time_->assign(value);
}
inline void Panel_LatestBlockTimeControl::set_latest_block_time(const char* value) {
  set_has_latest_block_time();
  if (latest_block_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_block_time_ = new ::std::string;
  }
  latest_block_time_->assign(value);
}
inline void Panel_LatestBlockTimeControl::set_latest_block_time(const char* value, size_t size) {
  set_has_latest_block_time();
  if (latest_block_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_block_time_ = new ::std::string;
  }
  latest_block_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_LatestBlockTimeControl::mutable_latest_block_time() {
  set_has_latest_block_time();
  if (latest_block_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_block_time_ = new ::std::string;
  }
  return latest_block_time_;
}
inline ::std::string* Panel_LatestBlockTimeControl::release_latest_block_time() {
  clear_has_latest_block_time();
  if (latest_block_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = latest_block_time_;
    latest_block_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_LatestBlockTimeControl::set_allocated_latest_block_time(::std::string* latest_block_time) {
  if (latest_block_time_ != &::google::protobuf::internal::kEmptyString) {
    delete latest_block_time_;
  }
  if (latest_block_time) {
    set_has_latest_block_time();
    latest_block_time_ = latest_block_time;
  } else {
    clear_has_latest_block_time();
    latest_block_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_identifier = 102;
inline bool Panel_LatestBlockTimeControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_LatestBlockTimeControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_LatestBlockTimeControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_LatestBlockTimeControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_LatestBlockTimeControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_LatestBlockTimeControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_LatestBlockTimeControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_LatestBlockTimeControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_LatestBlockTimeControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_LatestBlockTimeControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_LatestBlockTimeControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel_LatestProspectTimeControl

// required string latest_prospect_time = 1;
inline bool Panel_LatestProspectTimeControl::has_latest_prospect_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel_LatestProspectTimeControl::set_has_latest_prospect_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel_LatestProspectTimeControl::clear_has_latest_prospect_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel_LatestProspectTimeControl::clear_latest_prospect_time() {
  if (latest_prospect_time_ != &::google::protobuf::internal::kEmptyString) {
    latest_prospect_time_->clear();
  }
  clear_has_latest_prospect_time();
}
inline const ::std::string& Panel_LatestProspectTimeControl::latest_prospect_time() const {
  return *latest_prospect_time_;
}
inline void Panel_LatestProspectTimeControl::set_latest_prospect_time(const ::std::string& value) {
  set_has_latest_prospect_time();
  if (latest_prospect_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_prospect_time_ = new ::std::string;
  }
  latest_prospect_time_->assign(value);
}
inline void Panel_LatestProspectTimeControl::set_latest_prospect_time(const char* value) {
  set_has_latest_prospect_time();
  if (latest_prospect_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_prospect_time_ = new ::std::string;
  }
  latest_prospect_time_->assign(value);
}
inline void Panel_LatestProspectTimeControl::set_latest_prospect_time(const char* value, size_t size) {
  set_has_latest_prospect_time();
  if (latest_prospect_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_prospect_time_ = new ::std::string;
  }
  latest_prospect_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_LatestProspectTimeControl::mutable_latest_prospect_time() {
  set_has_latest_prospect_time();
  if (latest_prospect_time_ == &::google::protobuf::internal::kEmptyString) {
    latest_prospect_time_ = new ::std::string;
  }
  return latest_prospect_time_;
}
inline ::std::string* Panel_LatestProspectTimeControl::release_latest_prospect_time() {
  clear_has_latest_prospect_time();
  if (latest_prospect_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = latest_prospect_time_;
    latest_prospect_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_LatestProspectTimeControl::set_allocated_latest_prospect_time(::std::string* latest_prospect_time) {
  if (latest_prospect_time_ != &::google::protobuf::internal::kEmptyString) {
    delete latest_prospect_time_;
  }
  if (latest_prospect_time) {
    set_has_latest_prospect_time();
    latest_prospect_time_ = latest_prospect_time;
  } else {
    clear_has_latest_prospect_time();
    latest_prospect_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string study_identifier = 102;
inline bool Panel_LatestProspectTimeControl::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel_LatestProspectTimeControl::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel_LatestProspectTimeControl::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel_LatestProspectTimeControl::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel_LatestProspectTimeControl::study_identifier() const {
  return *study_identifier_;
}
inline void Panel_LatestProspectTimeControl::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_LatestProspectTimeControl::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel_LatestProspectTimeControl::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel_LatestProspectTimeControl::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel_LatestProspectTimeControl::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel_LatestProspectTimeControl::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Panel

// required string study_identifier = 1;
inline bool Panel::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Panel::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Panel::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Panel::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Panel::study_identifier() const {
  return *study_identifier_;
}
inline void Panel::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Panel::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Panel::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 102;
inline bool Panel::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Panel::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Panel::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Panel::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Panel::location() const {
  return *location_;
}
inline void Panel::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Panel::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Panel::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Panel::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Panel::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ProtoBuf.Panel.StudyNameControl study_name_control = 103;
inline bool Panel::has_study_name_control() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Panel::set_has_study_name_control() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Panel::clear_has_study_name_control() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Panel::clear_study_name_control() {
  if (study_name_control_ != NULL) study_name_control_->::ProtoBuf::Panel_StudyNameControl::Clear();
  clear_has_study_name_control();
}
inline const ::ProtoBuf::Panel_StudyNameControl& Panel::study_name_control() const {
  return study_name_control_ != NULL ? *study_name_control_ : *default_instance_->study_name_control_;
}
inline ::ProtoBuf::Panel_StudyNameControl* Panel::mutable_study_name_control() {
  set_has_study_name_control();
  if (study_name_control_ == NULL) study_name_control_ = new ::ProtoBuf::Panel_StudyNameControl;
  return study_name_control_;
}
inline ::ProtoBuf::Panel_StudyNameControl* Panel::release_study_name_control() {
  clear_has_study_name_control();
  ::ProtoBuf::Panel_StudyNameControl* temp = study_name_control_;
  study_name_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_study_name_control(::ProtoBuf::Panel_StudyNameControl* study_name_control) {
  delete study_name_control_;
  study_name_control_ = study_name_control;
  if (study_name_control) {
    set_has_study_name_control();
  } else {
    clear_has_study_name_control();
  }
}

// optional .ProtoBuf.Panel.TypeControl type_control = 104;
inline bool Panel::has_type_control() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Panel::set_has_type_control() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Panel::clear_has_type_control() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Panel::clear_type_control() {
  if (type_control_ != NULL) type_control_->::ProtoBuf::Panel_TypeControl::Clear();
  clear_has_type_control();
}
inline const ::ProtoBuf::Panel_TypeControl& Panel::type_control() const {
  return type_control_ != NULL ? *type_control_ : *default_instance_->type_control_;
}
inline ::ProtoBuf::Panel_TypeControl* Panel::mutable_type_control() {
  set_has_type_control();
  if (type_control_ == NULL) type_control_ = new ::ProtoBuf::Panel_TypeControl;
  return type_control_;
}
inline ::ProtoBuf::Panel_TypeControl* Panel::release_type_control() {
  clear_has_type_control();
  ::ProtoBuf::Panel_TypeControl* temp = type_control_;
  type_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_type_control(::ProtoBuf::Panel_TypeControl* type_control) {
  delete type_control_;
  type_control_ = type_control;
  if (type_control) {
    set_has_type_control();
  } else {
    clear_has_type_control();
  }
}

// optional .ProtoBuf.Panel.StatusControl status_control = 105;
inline bool Panel::has_status_control() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Panel::set_has_status_control() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Panel::clear_has_status_control() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Panel::clear_status_control() {
  if (status_control_ != NULL) status_control_->::ProtoBuf::Panel_StatusControl::Clear();
  clear_has_status_control();
}
inline const ::ProtoBuf::Panel_StatusControl& Panel::status_control() const {
  return status_control_ != NULL ? *status_control_ : *default_instance_->status_control_;
}
inline ::ProtoBuf::Panel_StatusControl* Panel::mutable_status_control() {
  set_has_status_control();
  if (status_control_ == NULL) status_control_ = new ::ProtoBuf::Panel_StatusControl;
  return status_control_;
}
inline ::ProtoBuf::Panel_StatusControl* Panel::release_status_control() {
  clear_has_status_control();
  ::ProtoBuf::Panel_StatusControl* temp = status_control_;
  status_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_status_control(::ProtoBuf::Panel_StatusControl* status_control) {
  delete status_control_;
  status_control_ = status_control;
  if (status_control) {
    set_has_status_control();
  } else {
    clear_has_status_control();
  }
}

// optional .ProtoBuf.Panel.VisibilityControl visibility_control = 106;
inline bool Panel::has_visibility_control() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Panel::set_has_visibility_control() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Panel::clear_has_visibility_control() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Panel::clear_visibility_control() {
  if (visibility_control_ != NULL) visibility_control_->::ProtoBuf::Panel_VisibilityControl::Clear();
  clear_has_visibility_control();
}
inline const ::ProtoBuf::Panel_VisibilityControl& Panel::visibility_control() const {
  return visibility_control_ != NULL ? *visibility_control_ : *default_instance_->visibility_control_;
}
inline ::ProtoBuf::Panel_VisibilityControl* Panel::mutable_visibility_control() {
  set_has_visibility_control();
  if (visibility_control_ == NULL) visibility_control_ = new ::ProtoBuf::Panel_VisibilityControl;
  return visibility_control_;
}
inline ::ProtoBuf::Panel_VisibilityControl* Panel::release_visibility_control() {
  clear_has_visibility_control();
  ::ProtoBuf::Panel_VisibilityControl* temp = visibility_control_;
  visibility_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_visibility_control(::ProtoBuf::Panel_VisibilityControl* visibility_control) {
  delete visibility_control_;
  visibility_control_ = visibility_control;
  if (visibility_control) {
    set_has_visibility_control();
  } else {
    clear_has_visibility_control();
  }
}

// optional .ProtoBuf.Panel.BlockCountControl block_count_control = 107;
inline bool Panel::has_block_count_control() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Panel::set_has_block_count_control() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Panel::clear_has_block_count_control() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Panel::clear_block_count_control() {
  if (block_count_control_ != NULL) block_count_control_->::ProtoBuf::Panel_BlockCountControl::Clear();
  clear_has_block_count_control();
}
inline const ::ProtoBuf::Panel_BlockCountControl& Panel::block_count_control() const {
  return block_count_control_ != NULL ? *block_count_control_ : *default_instance_->block_count_control_;
}
inline ::ProtoBuf::Panel_BlockCountControl* Panel::mutable_block_count_control() {
  set_has_block_count_control();
  if (block_count_control_ == NULL) block_count_control_ = new ::ProtoBuf::Panel_BlockCountControl;
  return block_count_control_;
}
inline ::ProtoBuf::Panel_BlockCountControl* Panel::release_block_count_control() {
  clear_has_block_count_control();
  ::ProtoBuf::Panel_BlockCountControl* temp = block_count_control_;
  block_count_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_block_count_control(::ProtoBuf::Panel_BlockCountControl* block_count_control) {
  delete block_count_control_;
  block_count_control_ = block_count_control;
  if (block_count_control) {
    set_has_block_count_control();
  } else {
    clear_has_block_count_control();
  }
}

// optional .ProtoBuf.Panel.CellCountControl cell_count_control = 108;
inline bool Panel::has_cell_count_control() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Panel::set_has_cell_count_control() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Panel::clear_has_cell_count_control() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Panel::clear_cell_count_control() {
  if (cell_count_control_ != NULL) cell_count_control_->::ProtoBuf::Panel_CellCountControl::Clear();
  clear_has_cell_count_control();
}
inline const ::ProtoBuf::Panel_CellCountControl& Panel::cell_count_control() const {
  return cell_count_control_ != NULL ? *cell_count_control_ : *default_instance_->cell_count_control_;
}
inline ::ProtoBuf::Panel_CellCountControl* Panel::mutable_cell_count_control() {
  set_has_cell_count_control();
  if (cell_count_control_ == NULL) cell_count_control_ = new ::ProtoBuf::Panel_CellCountControl;
  return cell_count_control_;
}
inline ::ProtoBuf::Panel_CellCountControl* Panel::release_cell_count_control() {
  clear_has_cell_count_control();
  ::ProtoBuf::Panel_CellCountControl* temp = cell_count_control_;
  cell_count_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_cell_count_control(::ProtoBuf::Panel_CellCountControl* cell_count_control) {
  delete cell_count_control_;
  cell_count_control_ = cell_count_control;
  if (cell_count_control) {
    set_has_cell_count_control();
  } else {
    clear_has_cell_count_control();
  }
}

// optional .ProtoBuf.Panel.ProspectCountControl prospect_count_control = 109;
inline bool Panel::has_prospect_count_control() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Panel::set_has_prospect_count_control() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Panel::clear_has_prospect_count_control() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Panel::clear_prospect_count_control() {
  if (prospect_count_control_ != NULL) prospect_count_control_->::ProtoBuf::Panel_ProspectCountControl::Clear();
  clear_has_prospect_count_control();
}
inline const ::ProtoBuf::Panel_ProspectCountControl& Panel::prospect_count_control() const {
  return prospect_count_control_ != NULL ? *prospect_count_control_ : *default_instance_->prospect_count_control_;
}
inline ::ProtoBuf::Panel_ProspectCountControl* Panel::mutable_prospect_count_control() {
  set_has_prospect_count_control();
  if (prospect_count_control_ == NULL) prospect_count_control_ = new ::ProtoBuf::Panel_ProspectCountControl;
  return prospect_count_control_;
}
inline ::ProtoBuf::Panel_ProspectCountControl* Panel::release_prospect_count_control() {
  clear_has_prospect_count_control();
  ::ProtoBuf::Panel_ProspectCountControl* temp = prospect_count_control_;
  prospect_count_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_prospect_count_control(::ProtoBuf::Panel_ProspectCountControl* prospect_count_control) {
  delete prospect_count_control_;
  prospect_count_control_ = prospect_count_control;
  if (prospect_count_control) {
    set_has_prospect_count_control();
  } else {
    clear_has_prospect_count_control();
  }
}

// optional .ProtoBuf.Panel.CreationTimeControl creation_time_control = 110;
inline bool Panel::has_creation_time_control() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Panel::set_has_creation_time_control() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Panel::clear_has_creation_time_control() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Panel::clear_creation_time_control() {
  if (creation_time_control_ != NULL) creation_time_control_->::ProtoBuf::Panel_CreationTimeControl::Clear();
  clear_has_creation_time_control();
}
inline const ::ProtoBuf::Panel_CreationTimeControl& Panel::creation_time_control() const {
  return creation_time_control_ != NULL ? *creation_time_control_ : *default_instance_->creation_time_control_;
}
inline ::ProtoBuf::Panel_CreationTimeControl* Panel::mutable_creation_time_control() {
  set_has_creation_time_control();
  if (creation_time_control_ == NULL) creation_time_control_ = new ::ProtoBuf::Panel_CreationTimeControl;
  return creation_time_control_;
}
inline ::ProtoBuf::Panel_CreationTimeControl* Panel::release_creation_time_control() {
  clear_has_creation_time_control();
  ::ProtoBuf::Panel_CreationTimeControl* temp = creation_time_control_;
  creation_time_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_creation_time_control(::ProtoBuf::Panel_CreationTimeControl* creation_time_control) {
  delete creation_time_control_;
  creation_time_control_ = creation_time_control;
  if (creation_time_control) {
    set_has_creation_time_control();
  } else {
    clear_has_creation_time_control();
  }
}

// optional .ProtoBuf.Panel.LatestBlockTimeControl latest_block_time_control = 111;
inline bool Panel::has_latest_block_time_control() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Panel::set_has_latest_block_time_control() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Panel::clear_has_latest_block_time_control() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Panel::clear_latest_block_time_control() {
  if (latest_block_time_control_ != NULL) latest_block_time_control_->::ProtoBuf::Panel_LatestBlockTimeControl::Clear();
  clear_has_latest_block_time_control();
}
inline const ::ProtoBuf::Panel_LatestBlockTimeControl& Panel::latest_block_time_control() const {
  return latest_block_time_control_ != NULL ? *latest_block_time_control_ : *default_instance_->latest_block_time_control_;
}
inline ::ProtoBuf::Panel_LatestBlockTimeControl* Panel::mutable_latest_block_time_control() {
  set_has_latest_block_time_control();
  if (latest_block_time_control_ == NULL) latest_block_time_control_ = new ::ProtoBuf::Panel_LatestBlockTimeControl;
  return latest_block_time_control_;
}
inline ::ProtoBuf::Panel_LatestBlockTimeControl* Panel::release_latest_block_time_control() {
  clear_has_latest_block_time_control();
  ::ProtoBuf::Panel_LatestBlockTimeControl* temp = latest_block_time_control_;
  latest_block_time_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_latest_block_time_control(::ProtoBuf::Panel_LatestBlockTimeControl* latest_block_time_control) {
  delete latest_block_time_control_;
  latest_block_time_control_ = latest_block_time_control;
  if (latest_block_time_control) {
    set_has_latest_block_time_control();
  } else {
    clear_has_latest_block_time_control();
  }
}

// optional .ProtoBuf.Panel.LatestProspectTimeControl latest_prospect_time_control = 112;
inline bool Panel::has_latest_prospect_time_control() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Panel::set_has_latest_prospect_time_control() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Panel::clear_has_latest_prospect_time_control() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Panel::clear_latest_prospect_time_control() {
  if (latest_prospect_time_control_ != NULL) latest_prospect_time_control_->::ProtoBuf::Panel_LatestProspectTimeControl::Clear();
  clear_has_latest_prospect_time_control();
}
inline const ::ProtoBuf::Panel_LatestProspectTimeControl& Panel::latest_prospect_time_control() const {
  return latest_prospect_time_control_ != NULL ? *latest_prospect_time_control_ : *default_instance_->latest_prospect_time_control_;
}
inline ::ProtoBuf::Panel_LatestProspectTimeControl* Panel::mutable_latest_prospect_time_control() {
  set_has_latest_prospect_time_control();
  if (latest_prospect_time_control_ == NULL) latest_prospect_time_control_ = new ::ProtoBuf::Panel_LatestProspectTimeControl;
  return latest_prospect_time_control_;
}
inline ::ProtoBuf::Panel_LatestProspectTimeControl* Panel::release_latest_prospect_time_control() {
  clear_has_latest_prospect_time_control();
  ::ProtoBuf::Panel_LatestProspectTimeControl* temp = latest_prospect_time_control_;
  latest_prospect_time_control_ = NULL;
  return temp;
}
inline void Panel::set_allocated_latest_prospect_time_control(::ProtoBuf::Panel_LatestProspectTimeControl* latest_prospect_time_control) {
  delete latest_prospect_time_control_;
  latest_prospect_time_control_ = latest_prospect_time_control;
  if (latest_prospect_time_control) {
    set_has_latest_prospect_time_control();
  } else {
    clear_has_latest_prospect_time_control();
  }
}

// -------------------------------------------------------------------

// Block

// optional string study_identifier = 1;
inline bool Block::has_study_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_study_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_study_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_study_identifier() {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    study_identifier_->clear();
  }
  clear_has_study_identifier();
}
inline const ::std::string& Block::study_identifier() const {
  return *study_identifier_;
}
inline void Block::set_study_identifier(const ::std::string& value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Block::set_study_identifier(const char* value) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(value);
}
inline void Block::set_study_identifier(const char* value, size_t size) {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  study_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Block::mutable_study_identifier() {
  set_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    study_identifier_ = new ::std::string;
  }
  return study_identifier_;
}
inline ::std::string* Block::release_study_identifier() {
  clear_has_study_identifier();
  if (study_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = study_identifier_;
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Block::set_allocated_study_identifier(::std::string* study_identifier) {
  if (study_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete study_identifier_;
  }
  if (study_identifier) {
    set_has_study_identifier();
    study_identifier_ = study_identifier;
  } else {
    clear_has_study_identifier();
    study_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool empty = 2 [default = true];
inline bool Block::has_empty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_empty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_empty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_empty() {
  empty_ = true;
  clear_has_empty();
}
inline bool Block::empty() const {
  return empty_;
}
inline void Block::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// repeated .ProtoBuf.Predictor predictor = 3;
inline int Block::predictor_size() const {
  return predictor_.size();
}
inline void Block::clear_predictor() {
  predictor_.Clear();
}
inline const ::ProtoBuf::Predictor& Block::predictor(int index) const {
  return predictor_.Get(index);
}
inline ::ProtoBuf::Predictor* Block::mutable_predictor(int index) {
  return predictor_.Mutable(index);
}
inline ::ProtoBuf::Predictor* Block::add_predictor() {
  return predictor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Predictor >&
Block::predictor() const {
  return predictor_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Predictor >*
Block::mutable_predictor() {
  return &predictor_;
}

// repeated .ProtoBuf.Specimen specimen = 4;
inline int Block::specimen_size() const {
  return specimen_.size();
}
inline void Block::clear_specimen() {
  specimen_.Clear();
}
inline const ::ProtoBuf::Specimen& Block::specimen(int index) const {
  return specimen_.Get(index);
}
inline ::ProtoBuf::Specimen* Block::mutable_specimen(int index) {
  return specimen_.Mutable(index);
}
inline ::ProtoBuf::Specimen* Block::add_specimen() {
  return specimen_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Specimen >&
Block::specimen() const {
  return specimen_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Specimen >*
Block::mutable_specimen() {
  return &specimen_;
}

// -------------------------------------------------------------------

// Predictor

// required uint64 name = 1;
inline bool Predictor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Predictor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Predictor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Predictor::clear_name() {
  name_ = GOOGLE_ULONGLONG(0);
  clear_has_name();
}
inline ::google::protobuf::uint64 Predictor::name() const {
  return name_;
}
inline void Predictor::set_name(::google::protobuf::uint64 value) {
  set_has_name();
  name_ = value;
}

// optional .ProtoBuf.Predictor.Status status = 2;
inline bool Predictor::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Predictor::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Predictor::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Predictor::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::ProtoBuf::Predictor_Status Predictor::status() const {
  return static_cast< ::ProtoBuf::Predictor_Status >(status_);
}
inline void Predictor::set_status(::ProtoBuf::Predictor_Status value) {
  assert(::ProtoBuf::Predictor_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .ProtoBuf.Predictor.Type type = 3;
inline bool Predictor::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Predictor::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Predictor::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Predictor::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::Predictor_Type Predictor::type() const {
  return static_cast< ::ProtoBuf::Predictor_Type >(type_);
}
inline void Predictor::set_type(::ProtoBuf::Predictor_Type value) {
  assert(::ProtoBuf::Predictor_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .ProtoBuf.Predictor.Level level = 4;
inline bool Predictor::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Predictor::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Predictor::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Predictor::clear_level() {
  level_ = 1;
  clear_has_level();
}
inline ::ProtoBuf::Predictor_Level Predictor::level() const {
  return static_cast< ::ProtoBuf::Predictor_Level >(level_);
}
inline void Predictor::set_level(::ProtoBuf::Predictor_Level value) {
  assert(::ProtoBuf::Predictor_Level_IsValid(value));
  set_has_level();
  level_ = value;
}

// repeated .ProtoBuf.Cell cell = 5;
inline int Predictor::cell_size() const {
  return cell_.size();
}
inline void Predictor::clear_cell() {
  cell_.Clear();
}
inline const ::ProtoBuf::Cell& Predictor::cell(int index) const {
  return cell_.Get(index);
}
inline ::ProtoBuf::Cell* Predictor::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::ProtoBuf::Cell* Predictor::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >&
Predictor::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >*
Predictor::mutable_cell() {
  return &cell_;
}

// -------------------------------------------------------------------

// Specimen

// optional uint64 key = 1;
inline bool Specimen::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specimen::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specimen::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specimen::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::uint64 Specimen::key() const {
  return key_;
}
inline void Specimen::set_key(::google::protobuf::uint64 value) {
  set_has_key();
  key_ = value;
}

// optional .ProtoBuf.Specimen.Status status = 2;
inline bool Specimen::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Specimen::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Specimen::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Specimen::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::ProtoBuf::Specimen_Status Specimen::status() const {
  return static_cast< ::ProtoBuf::Specimen_Status >(status_);
}
inline void Specimen::set_status(::ProtoBuf::Specimen_Status value) {
  assert(::ProtoBuf::Specimen_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint64 weight = 3;
inline bool Specimen::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Specimen::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Specimen::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Specimen::clear_weight() {
  weight_ = GOOGLE_ULONGLONG(0);
  clear_has_weight();
}
inline ::google::protobuf::uint64 Specimen::weight() const {
  return weight_;
}
inline void Specimen::set_weight(::google::protobuf::uint64 value) {
  set_has_weight();
  weight_ = value;
}

// optional bool empty = 4 [default = true];
inline bool Specimen::has_empty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Specimen::set_has_empty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Specimen::clear_has_empty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Specimen::clear_empty() {
  empty_ = true;
  clear_has_empty();
}
inline bool Specimen::empty() const {
  return empty_;
}
inline void Specimen::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// optional uint64 natural = 5;
inline bool Specimen::has_natural() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Specimen::set_has_natural() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Specimen::clear_has_natural() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Specimen::clear_natural() {
  natural_ = GOOGLE_ULONGLONG(0);
  clear_has_natural();
}
inline ::google::protobuf::uint64 Specimen::natural() const {
  return natural_;
}
inline void Specimen::set_natural(::google::protobuf::uint64 value) {
  set_has_natural();
  natural_ = value;
}

// optional sint64 integer = 6;
inline bool Specimen::has_integer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Specimen::set_has_integer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Specimen::clear_has_integer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Specimen::clear_integer() {
  integer_ = GOOGLE_LONGLONG(0);
  clear_has_integer();
}
inline ::google::protobuf::int64 Specimen::integer() const {
  return integer_;
}
inline void Specimen::set_integer(::google::protobuf::int64 value) {
  set_has_integer();
  integer_ = value;
}

// optional double real = 7;
inline bool Specimen::has_real() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Specimen::set_has_real() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Specimen::clear_has_real() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Specimen::clear_real() {
  real_ = 0;
  clear_has_real();
}
inline double Specimen::real() const {
  return real_;
}
inline void Specimen::set_real(double value) {
  set_has_real();
  real_ = value;
}

// repeated .ProtoBuf.Cell cell = 8;
inline int Specimen::cell_size() const {
  return cell_.size();
}
inline void Specimen::clear_cell() {
  cell_.Clear();
}
inline const ::ProtoBuf::Cell& Specimen::cell(int index) const {
  return cell_.Get(index);
}
inline ::ProtoBuf::Cell* Specimen::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::ProtoBuf::Cell* Specimen::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >&
Specimen::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Cell >*
Specimen::mutable_cell() {
  return &cell_;
}

// -------------------------------------------------------------------

// Cell

// optional uint64 name = 1;
inline bool Cell::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell::clear_name() {
  name_ = GOOGLE_ULONGLONG(0);
  clear_has_name();
}
inline ::google::protobuf::uint64 Cell::name() const {
  return name_;
}
inline void Cell::set_name(::google::protobuf::uint64 value) {
  set_has_name();
  name_ = value;
}

// optional uint64 key = 2;
inline bool Cell::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cell::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cell::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cell::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::uint64 Cell::key() const {
  return key_;
}
inline void Cell::set_key(::google::protobuf::uint64 value) {
  set_has_key();
  key_ = value;
}

// optional bool empty = 3 [default = true];
inline bool Cell::has_empty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cell::set_has_empty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cell::clear_has_empty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cell::clear_empty() {
  empty_ = true;
  clear_has_empty();
}
inline bool Cell::empty() const {
  return empty_;
}
inline void Cell::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// optional uint64 natural = 4;
inline bool Cell::has_natural() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cell::set_has_natural() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cell::clear_has_natural() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cell::clear_natural() {
  natural_ = GOOGLE_ULONGLONG(0);
  clear_has_natural();
}
inline ::google::protobuf::uint64 Cell::natural() const {
  return natural_;
}
inline void Cell::set_natural(::google::protobuf::uint64 value) {
  set_has_natural();
  natural_ = value;
}

// optional sint64 integer = 5;
inline bool Cell::has_integer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Cell::set_has_integer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Cell::clear_has_integer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Cell::clear_integer() {
  integer_ = GOOGLE_LONGLONG(0);
  clear_has_integer();
}
inline ::google::protobuf::int64 Cell::integer() const {
  return integer_;
}
inline void Cell::set_integer(::google::protobuf::int64 value) {
  set_has_integer();
  integer_ = value;
}

// optional double real = 6;
inline bool Cell::has_real() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cell::set_has_real() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Cell::clear_has_real() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Cell::clear_real() {
  real_ = 0;
  clear_has_real();
}
inline double Cell::real() const {
  return real_;
}
inline void Cell::set_real(double value) {
  set_has_real();
  real_ = value;
}

// optional uint64 special = 7;
inline bool Cell::has_special() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Cell::set_has_special() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Cell::clear_has_special() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Cell::clear_special() {
  special_ = GOOGLE_ULONGLONG(0);
  clear_has_special();
}
inline ::google::protobuf::uint64 Cell::special() const {
  return special_;
}
inline void Cell::set_special(::google::protobuf::uint64 value) {
  set_has_special();
  special_ = value;
}

// -------------------------------------------------------------------

// Message

// optional .ProtoBuf.Message.Type type = 101;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::Message_Type Message::type() const {
  return static_cast< ::ProtoBuf::Message_Type >(type_);
}
inline void Message::set_type(::ProtoBuf::Message_Type value) {
  assert(::ProtoBuf::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string text = 102;
inline bool Message::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Message::text() const {
  return *text_;
}
inline void Message::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Message::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoBuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Study_Type>() {
  return ::ProtoBuf::Study_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Study_Status>() {
  return ::ProtoBuf::Study_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Study_Visibility>() {
  return ::ProtoBuf::Study_Visibility_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Predictor_Status>() {
  return ::ProtoBuf::Predictor_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Predictor_Type>() {
  return ::ProtoBuf::Predictor_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Predictor_Level>() {
  return ::ProtoBuf::Predictor_Level_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Specimen_Status>() {
  return ::ProtoBuf::Specimen_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::Message_Type>() {
  return ::ProtoBuf::Message_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_yosokumo_2eproto__INCLUDED
